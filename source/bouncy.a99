*********************************************************************
* 
* Bouncy
* 
* For the TI-99/4A home computer.
* 
* To be assembled using xas99.
* 
* (c) Rasmus Moustgaard 2015 <rasmus.moustgaard@gmail.com>
* 
*********************************************************************

       def  start

vdp_int_from_status:
       equ  1

**
* Configuration
nlives:
       equ  2                                  ; Number of lives
slevel:
       equ  1                                  ; Start level
maxfrm:
       equ  7000                               ; Max frames to complete level

**
* Conditional assembly config
anympw:
       equ  1                                  ; Is any map width allowed?
hscrl:
       equ  0                                  ; Enable support for horizontal scrolling?
bgtime:
       equ  0                                  ; Use background color to visualize timing?

**
* Misc memory addresses
vdprd:
       equ  >8800                              ; VDP read data
vdpsta:
       equ  >8802                              ; VDP status
vdpwd:
       equ  >8c00                              ; VDP write data
vdpwa:
       equ  >8c02                              ; VDP set read/write address
rndsd:
       equ  >83c0                              ; Random number seed
sound:
       equ  >8400                              ; Sound
spchrd:
       equ  >9000
spchwt:
       equ  >9400


**
* VDP Memory Map
ptrntb:
       equ  >0000                              ; Pattern table base
ptrnt1:
       equ  >0800                              ; Pattern table part 2
ptrnt2:
       equ  >1000                              ; Pattern table part 3
sprptb:
       equ  >1800                              ; Sprite pattern table
spratb:
       equ  >1f80                              ; Sprite attribute table
colrtb:
       equ  >2000                              ; Color table base
namet0:
       equ  >2800                              ; Name table base 0
fixpat:
       equ  >2b00                              ; Backup of fixed patterns 112-127
fixcol:
       equ  >2b80                              ; Backup of fixed colors 112-127
namet1:
       equ  >2c00                              ; Name table base 1
fixmap:
       equ  >2f00                              ; Map of right side panel
namet2:
       equ  >3000                              ; Name table base 2
lgmap:
       equ  >3300                              ; Logo map
namet3:
       equ  >3400                              ; Name table base 3
lgpat:
       equ  >3700                              ; Logo patterns
lgcol:
       equ  >3b80                              ; Logo colors

**
* Scratch pad
wrksp:
       equ  >8300                              ; Workspace
stack:
       equ  >8320
r0lb:
       equ  wrksp+1                            ; R0 low byte required for VDP routines
r1lb:
       equ  wrksp+3
r2lb:
       equ  wrksp+5
r3lb:
       equ  wrksp+7
r4lb:
       equ  wrksp+9
r5lb:
       equ  wrksp+11
r6lb:
       equ  wrksp+13
r7lb:
       equ  wrksp+15
* Memory constants
one:
       equ  stack+16                           ; Constant 1
eight:
       equ  one+2                              ; Constant 8
bytec0:
       equ  eight+2                            ; Constant >C0
m_mapw:
       equ  bytec0+2                           ; Map width
* Variables
frame:
       equ  m_mapw+2                           ; Frame counter, reset when level begins
spr5th:
       equ  frame+2                            ; Index of the 5th sprite on a line
randno:
       equ  spr5th+2                           ; Random number
scrlct:
       equ  randno+2                           ; Counter for when to scroll
scrlx:
       equ  scrlct+2                           ; Horizontal scroll offset
scrlxv:
       equ  scrlx+2                            ; As SCRLX but for the visible screen
scrly:
       equ  scrlxv+2                           ; Vertical scroll offset
scrlyo:
       equ  scrly+2                            ; For saving old value of SCRLY
jmpfrm:
       equ  scrlyo+2                           ; Jump frame
jmp1st:
       equ  jmpfrm+2                           ; Zero if first jump frame, otherwise non-zero
jmpdx:
       equ  jmp1st+2                           ; X jump direction
jmpdy:
       equ  jmpdx+2                            ; Y jump direction
jmpz:
       equ  jmpdy+2                            ; Jump z position (height)
jmplen:
       equ  jmpz+2                             ; Jump length (0, 1, 2, 3)
autjmp:
       equ  jmplen+2                           ; Flag to indicate beginning of automatic jump
movdx:
       equ  autjmp+2                           ; Adjustment to x position caused by scrolling
movdxv:
       equ  movdx+2                            ; As MOVDX but for the visible screen
movdyv:
       equ  movdxv+2                           ; Adjustment to y position caused by scrolling
mtoffs:
       equ  movdyv+2                           ; Last modified meta tile screen offset
fsprno:
       equ  mtoffs+2                           ; Flicker routine sprite number
scoreh:
       equ  fsprno+2                           ; Score high word
scorel:
       equ  scoreh+2                           ; Score low word
energy:
       equ  scorel+2                           ; Energy
lives:
       equ  energy+2                           ; Lives
level:
       equ  lives+2                            ; Level number
lvlptr:
       equ  level+2                            ; Level pointer
lvlcmp:
       equ  lvlptr+2                           ; Level completed flag
lvllst:
       equ  lvlcmp+2                           ; Last played level number
died:
       equ  lvllst+2                           ; Died flag
status:
       equ  died+2                             ; Special status
mtswpt:
       equ  status+2                           ; Meta tile switch list pointer
mtswtl:
       equ  mtswpt+2                           ; The number of the meta tile displayed by a switch
cond:
       equ  mtswtl+2                           ; Condition (0=NORM, 1=DJMP, 2=IMMU, 2=CONF)
cndcnt:
       equ  cond+2                             ; Condition counter
pgift:
       equ  cndcnt+2                           ; Sprite pattern shown after sparkles
vcpy:
       equ  pgift+2                            ; VDP copy loop (22 bytes)
plyrws:
       equ  >83e0

* Assembler constants
scrint:
       equ  6                                  ; Frames between the screen is scrolled
mapw:
       .ifne anympw
       equ  24                                 ; Map width
       .else 
       equ  32                                 ; Map width
       .endif 
maph:
       equ  128                                ; Map height
vieww:
       equ  24                                 ; Viewport width
viewh:
       equ  24                                 ; Viewport height
scrnw:
       equ  32                                 ; Screen width
scrnh:
       equ  24                                 ; Screen height
panelw:
       equ  8                                  ; Panel width
panelh:
       equ  24                                 ; Panel height
y_diff:
       equ  3                                  ; Adjustment in y needed when converting
** between sprite and map coordinates.
** 1 is because screen coordinates start at >FF.
** Not sure about the other 2.
nlogop:
       equ  144

       .ifne hscrl
hsmarg:
       equ  24                                 ; Horizontal scroll margin
       .ifne anympw
hsxmin:
       equ  0                                  ; Minimum SCRLX
hsxmax:
       equ  0                                  ; Maximum SCRLX
       .else 
hsxmin:
       equ  0                                  ; Minimum SCRLX
hsxmax:
       equ  7                                  ; Maximum SCRLX
       .endif 
       .endif 

* Sprites and patterns
nspr:
       equ  14                                 ; Number of sprites
nsprpt:
       equ  56                                 ; Number of sprite patterns
aball:
       equ  0
ashadw:
       equ  52                                 ; Shadow attribute
pball0:
       equ  0
pball1:
       equ  8
pball2:
       equ  16
pball3:
       equ  24
pball4:
       equ  32
pball5:
       equ  40
nenemy:
       equ  4                                  ; Number of enemy sprites
aenemy:
       equ  8                                  ; First attribute for enemy sprites
penemy:
       equ  64                                 ; First enemy patterns
pdice:
       equ  64
psciss:
       equ  96
ptank:
       equ  128
pknife:
       equ  160
nspark:
       equ  3                                  ; Number of sparkle sprites
aspark:
       equ  40                                 ; First attribute for sparkle sprites
pspark:
       equ  48                                 ; First sparkle pattern
pxball:
       equ  192
pbonus:
       equ  196
pnrg:
       equ  200
pprf:
       equ  204
pgmo:
       equ  216
pempty:
       equ  252

* Meta tiles
mttile:
       equ  0                                  ; Tile
mtwate:
       equ  1                                  ; Water
mtques:
       equ  2                                  ; Question mark
mtcoin:
       equ  3                                  ; Coin
mtarro:
       equ  4                                  ; Arrow
mtfini:
       equ  5                                  ; Finish
mtlava:
       equ  6                                  ; Lava
mtspac:
       equ  7                                  ; Space

chzero:
       equ  240                                ; Zero character code
chnrg:
       equ  250                                ; First energy character code
chball:
       equ  126                                ; Ball character code
chspac:
       equ  255                                ; Space character code

* Level structure
lvl_mp:
       equ  0                                  ; Pointer to map
lvl_en:
       equ  2                                  ; Poniter to enemy definition list
lvl_sw:
       equ  4                                  ; Pointer to switch list
lvl_cl:
       equ  6                                  ; Pointer to color change list
lvl_sz:
       equ  8                                  ; Structure size

* Enemy structure
enm_tp:
       equ  0                                  ; Enemy type (0: eol, 1: bounded, >1: not bounded)
enm_x:
       equ  2                                  ; X position in map coordinates
enm_y:
       equ  4                                  ; Y position in map coordinates
enm_dx:
       equ  6                                  ; X velocity
enm_dy:
       equ  8                                  ; Y velocity
enm_pt:
       equ  10                                 ; Pattern number
enm_cl:
       equ  12                                 ; Colors 1st/2nd sprite
enm_at:
       equ  14                                 ; Pointer to sprite attributes, 0 if not allocated
enm_ct:
       equ  16                                 ; Movement counter
enm_sz:
       equ  18                                 ; Structure size

* Enemy definition structure
end_tp:
       equ  0                                  ; Enemy type (0: eol, 1: bounded, >1: not bounded)
end_x:
       equ  1                                  ; X position in meta tiles
end_y:
       equ  2                                  ; Y position in meta tiles
end_dx:
       equ  3                                  ; X velocity
end_dy:
       equ  4                                  ; Y velocity
end_pt:
       equ  5                                  ; Pattern number
end_c1:
       equ  6                                  ; Color 1st sprite layer
end_c2:
       equ  7                                  ; Color 2nd sprite layer
end_sz:
       equ  8                                  ; Structure size

* Switch structure
sw_x:
       equ  0                                  ; x position of switch (meta tiles)
sw_y:
       equ  1                                  ; y position of switch (meta tiles)
sw_mts:
       equ  2                                  ; Pointer to zero terminated list coordinates
sw_sz:
       equ  4                                  ; of meta tile to trigger.

* Condition
cn_norm:
       equ  0                                  ; Normal
cn_djmp:
       equ  1                                  ; Double jump
cn_immu:
       equ  2                                  ; Immunity
cn_conf:
       equ  3                                  ; Confusion
cn_sped:
       equ  4                                  ; Speed

***************************************************************************
* 
* Main program
* 
       aorg >a000

start:
       limi 0                                  ; Disable interrupts
       lwpi wrksp                              ; Set workspace
       li   r10,stack                          ; Set up stack pointer
* Init
       bl   @init
* Display logo
newgme:
       bl   @dsplgo
* Init game
       bl   @inigme
* Init level
newlvl:
       bl   @inilvl
* Main loop
loop:
       bl   @vsync
* Play music
       bl   @playmu
* Upload sprite attributes
       bl   @flickr
* Scroll
       bl   @scroll
* Update switched meta tiles
       bl   @updsmt
* Check frame
       bl   @chkfrm
* Manage condition counter
       bl   @mgcond
* Map position
       bl   @mappos
* Enemy collisions
       bl   @enmcol
* Read joystick
       bl   @joyst
* Move ball
       bl   @movbal
* Move enemies
       bl   @movenm
* Display sparkle sprites
       bl   @sparkl
* Display time
       bl   @dsptme
* Check quit
       bl   @ckquit
* Next frame
nxtfrm:
       mov  @frame,r0
       ci   r0,maxfrm
       jne  nxtfr1
       mov  @one,@died
nxtfr1:
       inc  r0
       mov  r0,@frame
       .ifne bgtime
       li   r0,>070f
       bl   @vwtr
       .endif 
* Check for level done
       mov  @lvlcmp,r0
       jne  newlvl
* Check if died
       mov  @died,r0
       jlt  dead
* Loop
       jmp  loop
* Dead
dead:
       bl   @mtesnd
       li   r2,30
       bl   @pause
       dec  @lives
       jgt  newlvl
       jeq  newlvl
       bl   @gmeovr
       jmp  newgme

***************************************************************************
* 
* One time initializations
init:
       mov  r11,*r10+                          ; Push return address onto the stack
* Save random number seed
       mov  @rndsd,@randno
* Init constants
       li   r0,1
       mov  r0,@one
       li   r0,8
       mov  r0,@eight
       li   r0,>c000
       mov  r0,@bytec0
       li   r0,mapw
       mov  r0,@m_mapw
* Copy VDP copy loop to scratch pad
       li   r0,vcpy
       li   r1,vcpy8
       li   r2,vcpy8e-vcpy8
       bl   @copy
* Init graphics mode
       bl   @gmode
* Upload static patterns to VDP
       li   r4,fpdata
       li   r5,15                              ; Number of segments to upload
init1:
       mov  *r4+,r0
       mov  *r4+,r1
       mov  *r4+,r2
       bl   @vdpcp
       dec  r5
       jne  init1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Destination, source, and length of uploaded data
fpdata:
* Fixed chars 112-127
       data 112*8+ptrntb,fpt112,16*8
       data 112*8+ptrntb+>800,fpm112,16*8
       data 112*8+ptrntb+>1000,fpb112,16*8
       data 112*8+colrtb,fcl112,16*8
       data fixpat,fpm112,16*8
       data fixcol,fcl112,16*8
* Fixed char 240-255
       data 240*8+ptrntb,fpt240,16*8
       data 240*8+ptrntb+>800,fpm240,16*8
       data 240*8+ptrntb+>1000,fpb240,16*8
       data 240*8+colrtb,fcl240,16*8
* Panel map
       data fixmap,pnlmap,8*24
* Sprite patterns
       data sprptb,spr0,nsprpt*32
* Logo map
       data lgmap,lmap,256
* Logo patterns
       data lgpat,lpat0,nlogop*8
* Upload logo colors
       data lgcol,lcol0,nlogop*8
* // INIT

***************************************************************************
* 
* New game initializations
* 
inigme:
       mov  r11,*r10+                          ; Push return address onto the stack
       clr  @scoreh
       clr  @scorel
       li   r0,slevel
       mov  r0,@level
       dec  r0
       li   r1,lvl_sz
       mpy  r1,r0
       ai   r1,levels
       mov  r1,@lvlptr
       clr  @lvllst
       li   r0,nlives
       mov  r0,@lives
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // INIGME

***************************************************************************
* 
* New level initializations
* 
inilvl:
       mov  r11,*r10+                          ; Push return address onto the stack
       bl   @mtesnd
* Copy level info into place
       mov  @lvlptr,r12
* Copy enemy list
* Note: Should really use structure EQUs
       li   r0,enmlst                          ; Pointer to destination enemy list
       mov  @lvl_en(r12),r1                    ; Pointer to source enemy definition list
       mov  *r1+,r2                            ; Number of entries
       jeq  inilv6
inilv5:
       clr  r3                                 ; Type
       movb *r1+,@r3lb
       mov  r3,*r0+
       clr  r3                                 ; X position
       movb *r1+,@r3lb
       sla  r3,4
       mov  r3,*r0+
       clr  r3                                 ; Y position
       movb *r1+,@r3lb
       sla  r3,4
       mov  r3,*r0+
       movb *r1+,r3                            ; X velocity
       sra  r3,8
       mov  r3,*r0+
       movb *r1+,r3                            ; Y velocity
       sra  r3,8
       mov  r3,*r0+
       clr  r3                                 ; Pattern number
       movb *r1+,@r3lb
       mov  r3,*r0+
       mov  *r1+,*r0+                          ; Colors
       clr  *r0+                               ; Pointer to sprite attributes
       mov  r2,r3
       inc  r3
       mov  r3,*r0+                            ; Counter
       dec  r2
       jne  inilv5
inilv6:
       clr  *r0+                               ; End marker
* Copy switch list
       li   r0,swlist
       mov  @lvl_sw(r12),r1
       mov  *r1+,r2
       bl   @copy
* Unpack meta tile map
       mov  @lvl_mp(r12),r0
       li   r1,mtmap
       bl   @unpack
* Expand meta tile map to MAP
       li   r0,mtmap
       li   r1,mtiles
       bl   @expmap
* Initialize the scroll tile map
       bl   @inist
* Only if level number changed
       c    @level,@lvllst
       jeq  inilv3
* Pre-scroll patterns
       li   r0,pats                            ; Base pattern address
       li   r1,ptfrm0                          ; Destination address
       bl   @pscrl                             ; Pre-scroll patterns
* Pre-scroll colors
       li   r0,cols                            ; Base color address
       li   r1,clfrm0                          ; Destination address
       bl   @pscrl                             ; Pre-scroll colors
* Change colors
       mov  @lvl_cl(r12),r0
       bl   @chgclr
inilv3:
* Init scrolling variables
       .ifne hscrl
       li   r0,hsxmax-hsxmin+1/2+hsxmin
       mov  r0,@scrlx
       mov  r0,@scrlxv
       .endif 
       li   r0,maph                            ; Get map height in rows
       ai   r0,-scrnh                          ; Subtract one screen
       sla  r0,3                               ; Convert to pixels
       dec  r0                                 ; See INISCR
       mov  r0,@scrly                          ; Start at the bottom of the map
       clr  @scrlct                            ; Initialize scroll counter
* Init other variables
       clr  @frame
       clr  @jmpfrm
       li   r0,1
       mov  r0,@jmplen
       clr  @movdx
       clr  @movdxv
       clr  @movdyv
       clr  @jmpz
       li   r0,2
       mov  r0,@fsprno                         ; Flicker routine sprite number
       clr  @lvlcmp
       clr  @died
       clr  @mtswpt
       clr  @cond
       clr  @cndcnt
       clr  @pgift
* Wait for fire
       mov  @lvllst,r0
       jne  inilv4
* Display "Press Fire"
       bl   @prfire
* Screen off
       li   r0,>01a2
       bl   @vwtr
* Display initial screen
inilv4:
       bl   @iniscr
* Right panel
       mov  @lvllst,r0
       jne  inilv2
       bl   @dsppnl
* Display lives
inilv2:
       bl   @dsplvs
* Display level
       bl   @dsplvl
* Restore energy
       bl   @rstnrg
* Restore time
       bl   @rsttme
* Restore ball color
       clr  r1
       bl   @setclr
* Restore ball position
       li   r0,spratt+aball
       li   r1,>8060
       mov  r1,*r0+
       inct r0
       mov  r1,*r0
       li   r0,spratt+ashadw
       mov  r1,*r0
* Place other sprites out of screen
       li   r0,spratt+aenemy
       li   r1,>c000
       li   r2,nspr-3
inilv1:
       mov  r1,*r0+
       inct r0
       dec  r2
       jne  inilv1
* Sprites attribute end marker
       li   r0,nspr*4+spratb
       li   r1,>d000
       bl   @vsbw
* Init music
       bl   @initmu
* Set name table
       li   r0,>020d
       bl   @vwtr
* Screen on
       li   r0,>01e2
       bl   @vwtr
* Wait a little
       bl   @flickr
       li   r2,60
       bl   @pause
* Save last level
       mov  @level,@lvllst
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // INILVL

***************************************************************************
* 
* Display "Press fire"
* 
prfire:
       mov  r11,*r10+                          ; Push return address onto the stack
* Upload attributes
       li   r0,spratb
       li   r1,prfatt
       li   r2,13
       bl   @vmbw
* Animate
       movb @prfatt,r3                         ; y position
       li   r4,prfdat                          ; Pointer to animation data
prfir1:
       clr  r2
       movb *r4+,@r2lb                         ; Get repeat count
       jeq  prfir3
       clr  r5
       movb *r4+,r5                            ; Get y increment
prfir2:
       ab   r5,r3
       mov  r3,r1
       li   r0,spratb
       bl   @vsbw
       li   r0,spratb+4
       bl   @vsbw
       li   r0,spratb+8
       bl   @vsbw
       bl   @vsync
       li   r0,>0606                           ; Fire button
       bl   @chkkey
       jne  prfir4
       dec  r2
       jne  prfir2
       jmp  prfir1
prfir3:
       clr  r2
       bl   @wtfire
* Return
prfir4:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
prfdat:
       byte 60,0,16,1,8,2,4,4
       byte 2,-4,2,-2,2,-1,4,0
       byte 2,1,2,2,2,4
       byte 2,-2,2,-1,4,0,2,1,2,2
       byte 0,0
* // PRFIRE

***************************************************************************
* 
* Level complete
* 
lvlovr:
       mov  r11,*r10+                          ; Push return address onto the stack
       seto @lvlcmp
       inc  @level
       mov  @lvlptr,r0
       ai   r0,lvl_sz
       mov  *r0,r1
       jne  lvlov1
       li   r0,levels
lvlov1:
       mov  r0,@lvlptr
       li   r0,finish
       bl   @speak                             ; Say something
lvlov2:
       mov  @frame,r0
       ci   r0,maxfrm
       jhe  lvlov3
       bl   @vsync
       bl   @dsptme
       li   r0,11
       bl   @addsco
       mov  @frame,r0
       ai   r0,16
       mov  r0,@frame
       andi r0,32
       jne  lvlov4
       bl   @mtesnd
       jmp  lvlov2
lvlov4:
       li   r0,tcksnd
       bl   @plysnd
       jmp  lvlov2
* Return
lvlov3:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
tcksnd:
       byte >03,>8f,>07,>90
* // LVLOVR

***************************************************************************
* 
* Game over
* 
gmeovr:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r0,spratb
       li   r1,gmoatt
       li   r2,17
       bl   @vmbw
       li   r2,18000                           ; Wait up to 5 minutes
       bl   @wtfire
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // GMEOVR

***************************************************************************
* 
* Pause
* 
* r2: Number of frames to wait
* 
pause:
       mov  r11,*r10+                          ; Push return address onto the stack
pause1:
       bl   @vsync
       dec  r2
       jne  pause1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // PAUSE

***************************************************************************
* 
* Wait for vertical retrace (CRU)
* 
vsync:
       clr  @spr5th
       .ifeq vdp_int_from_status,0
       clr  r12
vsync1:
       tb   2                                  ; Test CRU bit for VDP interrupt
       jeq  vsync1
       movb @vdpsta,r0
       .else 
vsync2:
       movb @vdpsta,r0
       mov  r0,r1
       andi r1,>8000
       jeq  vsync2
       .endif 
       andi r0,>4000
       jeq  vsync3
       andi r1,>1f00
       swpb r1
       mov  r1,@spr5th
vsync3:
       b    *r11
* // VSYNC

***************************************************************************
* 
* Upload sprite attributes (flicker routine)
* 
flickr:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0703
       bl   @vwtr
       .endif 
* Always copy ball sprites first (not including shadow)
       li   r0,spratb                          ; Destination
       li   r1,spratt
       li   r2,8
       bl   @vdpcp
* Then copy remaining sprites starting from a changing position
       mov  @spr5th,r4                         ; Get number of 5th sprite on a line
       jne  flick1
* No 5th sprite - just start at the beginning
flick0:
       li   r4,2
       jmp  flick2
* 5th sprite
flick1:
       ci   r4,nspr-1                          ; Avoid bug in Classic99 where >1F is returned as 5th sprite
       jgt  flick0
       a    @fsprno,r4                         ; Add last start position
       dect r4                                 ; Because we start at 2
       ci   r4,nspr                            ; Check for overflow
       jlt  flick2
       ai   r4,-nspr+2                         ; Wrap around
flick2:
       mov  r4,r1                              ; Place in source address
       sla  r1,2                               ; Multiply by four
       ai   r1,spratt                          ; Add base address
       li   r2,nspr                            ; Total number of sprites
       s    r4,r2                              ; Subtract start sprite
       sla  r2,2                               ; Multiply by four
       bl   @vdpcp0                            ; Copy
       ci   r4,2                               ; Test if we started at beginning
       jeq  flick3                             ; No more to do
       li   r1,spratt+8                        ; Source address
       mov  r4,r2                              ; Start sprite
       dect r2                                 ; Minus 2 (because we start at 2)
       sla  r2,2                               ; Multiply by four
       bl   @vdpcp0                            ; Copy
flick3:
       mov  r4,@fsprno                         ; Save start position
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // FLICKR

***************************************************************************
* 
* Scroll the screen
* 
* Called every frame, but actually only scrolls every 6th frame.
* In other frames it does part of the work to prepare the buffers.
* 
* Frame 5: Set name table, change scroll offset, update patterns #5, updated name table #5
* Frame 4: Update patterns #4, updated name table #4
* Frame 3: Update patterns #3, updated name table #3
* Frame 2: Update patterns #2, updated name table #2
* Frame 1: Update patterns #1, updated name table #1
* Frame 0: Update patterns #0, updated name table #0
* 
scroll:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0704
       bl   @vwtr
       .endif 
* Check scroll counter
       mov  @scrlct,r0
       jne  scrol2
* Every 6th frame {
* Reset scroll counter
       li   r0,scrint                          ; Set to 6
       mov  r0,@scrlct
* Set name table
       bl   @setnt                             ; This is what actually scrolls the screen
* Change scroll offset
       mov  @scrly,r0
       jeq  scrol3                             ; Check for top of map
       mov  r0,@scrlyo                         ; Save scroll offset, for use in UPDPT
       dec  r0
       mov  r0,@scrly
* Adjust ball position
       mov  @one,@movdyv
* Horizontal scrolling
       .ifne hscrl
       andi r0,>0007
       ci   r0,>0007                           ; Only before we start updating a new set of buffers
       jne  scrol2
       bl   @hscrol
       .endif 
* }
* Every frame {
* Decrement counter (5 to 0)
scrol2:
       dec  @scrlct
* Update patterns
       bl   @updpt
* Update name table buffer
       bl   @updnt
* }
* Return
scrol3:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SCROLL

***************************************************************************
* 
* Horizontal scrolling
* 
       .ifne hscrl
hscrol:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @movdx,r0
       jeq  hscro1
       mov  r0,@movdxv
       clr  @movdx
       mov  @scrlx,@scrlxv                     ; Update the visible scroll offset
hscro1:
       clr  r1
       movb @spratt+1,@r1lb                    ; Get x position
       a    @movdxv,r1
       ci   r1,hsmarg-1
       jgt  hscro2
       mov  @scrlx,r1
       ci   r1,hsxmin
       jeq  hscro9
       dec  r1
       mov  r1,@scrlx
       li   r1,8
       mov  r1,@movdx
       jmp  hscro9
hscro2:
       ci   r1,256-80-hsmarg-1
       jlt  hscro9
       mov  @scrlx,r1
       ci   r1,hsxmax
       jeq  hscro9
       inc  r1
       mov  r1,@scrlx
       li   r1,-8
       mov  r1,@movdx
* Return
hscro9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
       .endif 
* // HSCROL

***************************************************************************
* 
* Check if we are in the frame just before a jump begins
* 
chkfrm:
       mov  @jmpfrm,r0
       mov  @cond,r1
       ci   r1,cn_sped                         ; Check for speed condition
       jne  chkfr1
       sla  r0,1
chkfr1:
       mov  @jmplen,r1
       sla  r1,1
       szc  @jmpmsk(r1),r0
       mov  r0,@jmp1st                         ; Save as a flag
       b    *r11
jmpmsk:
       data >0000,>ffe0,>ffc0,>ff80
* // CHKFRM

***************************************************************************
* 
* Manage condition counter
* 
mgcond:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @cndcnt,r0
       jeq  mgcon2
       dec  r0
       jne  mgcon1
       mov  @jmp1st,r1                         ; Only end condition in first frame
       jne  mgcon3
       clr  @cond
       clr  r1                                 ; Normal color
       bl   @setclr
       jmp  mgcon1
mgcon3:
       inc  r0                                 ; Set counter back to one
mgcon1:
       mov  r0,@cndcnt
* Return
mgcon2:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // MGCOND

***************************************************************************
* 
* Find position on map
* 
mappos:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0706
       bl   @vwtr
       .endif 
* Skip if dead
       mov  @died,r0                           ; Check died flag
       jne  mappo1
* Check if we are in the frame just before a jump begins
       mov  @jmp1st,r0
       jne  mappo1
* Clear automatic jump flag
       clr  @autjmp
* Find position
       clr  r0
       movb @spratt+1,@r0lb                    ; Get x position of ball
       ai   r0,8
       clr  r1
       movb @spratt,@r1lb                      ; Get y position of ball
       ai   r1,8
       bl   @getmt                             ; Get meta tile at position
** Tile number in r0, map offset in r1
       sla  r0,1                               ; Convert meta tile number to word offset
       ai   r0,maptbl                          ; Add jump table base
       mov  *r0,r0                             ; Get jump address
       b    *r0
* Tile
mptile:
       jmp  mappo1
* Water
mpwate:
       li   r1,8
       mov  @cond,r0
       ci   r0,cn_immu                         ; Check for immunity
       jne  mappo3
       srl  r1,1                               ; Half damage when immune
mappo3:
       bl   @decnrg
       jmp  mappo1
* Question mark
mpques:
       bl   @questm
       jmp  mappo1
* Coin
mpcoin:
       li   r0,mttile                          ; Change to tile
       bl   @setmt
       bl   @ispark                            ; Init sparkle
       li   r0,125
       bl   @addsco                            ; Add score
* LI   r1,FXCOIN
* CLR  r2
* BL   @playsfx
       jmp  mappo1
* Long jump arrow
mparro:
       li   r0,3
       mov  r0,@jmplen                         ; Jump length 3
       clr  @jmpfrm
       clr  @jmpdx                             ; Vertical
       seto @jmpdy
       seto @autjmp                            ; Set flag
* LI   r1,FXJUMP
* CLR  r2
* BL   @playsfx
       jmp  mappo1
* Finish - next level
mpfini:
       bl   @lvlovr
       jmp  mappo1
* Lava
mplava:
       li   r1,8
       mov  @cond,r0
       ci   r0,cn_immu                         ; Check for immunity
       jne  mappo4
       srl  r1,1                               ; Half damage when immune
mappo4:
       bl   @decnrg
       mov  @jmpdx,r0
       jne  mappo5
       mov  @jmpdy,r0
       jne  mappo5
       jmp  mappo6
mappo5:
       neg  @jmpdx
       neg  @jmpdy
       mov  @one,@autjmp
       clr  @jmpfrm
mappo6:
       li   r0,no
       bl   @speak                             ; Say something
       jmp  mappo1
* Space
mpspac:
       mov  @died,r0
       jne  mappo1
       mov  @one,@died
       clr  @jmpfrm
* LI   r0,NO
* BL   @SPEAK              * Say something
       jmp  mappo1
* Return
mappo1:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
maptbl:
       data mptile,mpwate,mpques,mpcoin,mparro,mpfini,mplava,mpspac
* // MAPPOS

***************************************************************************
* 
* Enemy collisions
* 
enmcol:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0707
       bl   @vwtr
       .endif 
       mov  @cond,r0                           ; Check for immunity condition
       ci   r0,cn_immu
       jeq  enmco9
       clr  r4
       movb @spratt+1,@r4lb                    ; Get ball x
       clr  r5
       movb @spratt,@r5lb                      ; Get ball y
       clr  r6
       clr  r7
       li   r3,enmlst                          ; Pointer to enemy list
enmco1:
       mov  *r3,r0                             ; Get first word of enemy structure
       jeq  enmco9                             ; Zero terminates list
       mov  @enm_at(r3),r0                     ; Get attributes address
       jeq  enmco8                             ; Skip if not allocated
       movb *r0+,@r7lb                         ; Get enemy y
       movb *r0,@r6lb                          ; Get enemy x
       s    r4,r6                              ; Enemy x - ball x
       abs  r6
       ci   r6,12                              ; Compare to sprite width
       jgt  enmco8
       s    r5,r7                              ; Enemy y - ball y
       abs  r7
       ci   r7,12                              ; Compare to sprite width
       jgt  enmco8
* Collision
       mov  @jmpz,r0                           ; Check jump height
       ci   r0,5
       jgt  enmco8                             ; Skip collision if at top of jump
       li   r1,1
       bl   @decnrg                            ; Zap energy
       jmp  enmco9                             ; No more enemies checked
enmco8:
       ai   r3,enm_sz
       jmp  enmco1
* Return
enmco9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // ENMCOL

***************************************************************************
* 
* Read joystick
* 
joyst:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0709
       bl   @vwtr
       .endif 
* No control if dead
       mov  @died,r0                           ; Check died flag
       jne  joystb
* Check if jump length/direction has already been set by landing in lava
       mov  @autjmp,r0
       jgt  joystb                             ; No control
* Read joystick using CRU
       li   r12,>0024                          ; CRU address of the column decoder
       li   r0,>0600                           ; Column 6, i.e joystick #1
       ldcr r0,3                               ; Select it
       li   r12,>0006                          ; Base CRU address for joystick 1
* Get condition
       mov  @cond,r1
* Check if jump length/direction has already been set by landing on an arrow
       mov  @autjmp,r0
       jne  joyst5                             ; Limited control
* Allow a change in jump length/direction in the frame just before a jump begins
       mov  @jmp1st,r0
       jeq  joysta                             ; Full control
* For jump length 1 we always allow a change in direction
       c    @one,@jmplen
       jeq  joyst0                             ; Direction control
       jmp  joyst5                             ; Limited control
* Init jump type variables
joysta:
       mov  @one,@jmplen
       ci   r1,cn_djmp                         ; Check condition
       jne  joystc
       inc  @jmplen                            ; Double jump condition
joystc:
       clr  @jmpfrm                            ; Clear the jump frame - important if we go from long to short jump
* Fire button
       tb   0
       jeq  joyst0
       inc  @jmplen
* Init direction variables
joyst0:
       clr  @jmpdy
       clr  @jmpdx
* Left
       tb   1
       jeq  joyst1
       seto @jmpdx                             ; DX=-1
       jmp  joyst2
* Right
joyst1:
       tb   2
       jeq  joyst2
       mov  @one,@jmpdx                        ; DX=1
* Down
joyst2:
       tb   3
       jeq  joyst3
       mov  @one,@jmpdy                        ; DY=1
       jmp  joyst9
* Up
joyst3:
       tb   4
       jeq  joyst9
       seto @jmpdy                             ; DY=-1
       jmp  joyst9
* If a jump is already ongoing we allow stopping in mid air
* Left
joyst5:
       tb   1
       jeq  joyst6
       ci   r1,cn_conf                         ; Check condition
       jeq  joyste                             ; If confused do as if moving right
joystd:
       mov  @jmpdx,r0
       jlt  joyst7
       clr  @jmpdx                             ; DX=0
       jmp  joyst7
* Right
joyst6:
       tb   2
       jeq  joyst7
       ci   r1,cn_conf                         ; Check condition
       jeq  joystd                             ; If confused do as if moving left
joyste:
       mov  @jmpdx,r0
       jgt  joyst7
       clr  @jmpdx                             ; DX=0
       jmp  joyst7
* Down
joyst7:
       tb   3
       jeq  joyst8
       ci   r1,cn_conf                         ; Check condition
       jeq  joystg                             ; If confused do as if moving up
joystf:
       mov  @jmpdy,r0
       jgt  joystb
       clr  @jmpdy                             ; DY=0
       jmp  joystb
* Up
joyst8:
       tb   4
       jeq  joystb
       ci   r1,cn_conf                         ; Check condition
       jeq  joystf                             ; If confused do as if moving down
joystg:
       mov  @jmpdy,r0
       jlt  joystb
       clr  @jmpdy                             ; DY=0
       jmp  joystb
* Confused condition
joyst9:
       ci   r1,cn_conf                         ; Check for confusion
       jne  joystb
       neg  @jmpdx                             ; Invert x movement
       neg  @jmpdy                             ; Invert y movement
* Return
joystb:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // JOYST

***************************************************************************
* 
* Move ball
* 
movbal:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>070a
       bl   @vwtr
       .endif 
* Animate ball
       mov  @jmpfrm,r1                         ; Get animation frame
       mov  @cond,r0
       ci   r0,cn_sped                         ; Check for speed condition
       jeq  movbag
       li   r0,1                               ; Check for odd frame
       coc  r0,r1
       jne  movba2                             ; Skip even frames
       srl  r1,1                               ; Shift out least significant bit
movbag:
       mov  @died,r0                           ; Check if died
       jne  movbae
* If jump length now has the bits x5 x4 x3 x2 x1 x0
* For jump length 1 we want x3 x2 x1 x0: 0,1,2,3,...,15
* For jump length 2 we want x4 x3 x2 x0: 0,1,0,1,2,3,2,3,...,14,15,14,15
* For jump length 3 we want x5 x4 x3 x0: 0,1,0,1,0,1,0,1,2,3,2,3,2,3,2,3,...,14,15,14,15,14,15,14,15
* To use as index in the jump pattern and height tables
       mov  @jmplen,r0                         ; Get jump length
       jeq  movba6                             ; Check for zero
       mov  r1,r2                              ; Copy frame to R2
       dec  r0                                 ; Prepare to shift jumpLength - 1
       jeq  movba8                             ; No shift if zero
       srl  r2,0                               ; Shift
movba8:
       andi r2,>000e                           ; Only keep 3 bits
       andi r1,>0001                           ; Plus the least significant bit
       soc  r2,r1                              ; OR them together to get 4 bits
       jmp  movba5
* Jump length 0 - no movement
movba6:
       clr  r2
       clr  r5
       jmp  movba7
movba5:
       movb @jmppat(r1),r2                     ; Get sprite pattern to display
       movb @jmphgt(r1),r5                     ; Get height change
* Horizontal movement
movba7:
       clr  r6
       movb @spratt+1,@r6lb                    ; Get x position
       mov  @jmpdx,r3                          ; Check jump direction
       a    @movdxv,r3                         ; Adjust for scrolling
       jeq  movba3
       jgt  movba4
       ci   r6,0                               ; Check left boundary
       jgt  movba3
       jmp  movba9
movba4:
       ci   r6,256-80                          ; Check right boundary
       jlt  movba3
movba9:
       clr  r3                                 ; Stop movement
movba3:
       swpb r3
* Vertical movement
       clr  r7
       movb @spratt,@r7lb                      ; Get y position
       mov  @jmpdy,r4                          ; Get jump direction
       a    @movdyv,r4                         ; Adjust for scrolling
       jeq  movba1
       jgt  movbab
       ci   r7,0                               ; Check top boundary
       jgt  movba1
       jmp  movbac
movbab:
       ci   r7,192-17                          ; Check bottom boundary
       jlt  movba1
movbac:
       clr  r4                                 ; Stop movement
movba1:
       swpb r4
       li   r0,aball+spratt                    ; Address of sprite attributes in CPU RAM
* Top layer
       ab   r4,*r0+
       ab   r3,*r0+
       movb r2,*r0+                            ; Set pattern
       inc  r0                                 ; Advance to y attribute of next sprite
* Bottom layer
       ab   r4,*r0+
       ab   r3,*r0+
       ai   r2,>0400                           ; Next pattern
       movb r2,*r0+                            ; Set pattern
       inc  r0                                 ; Advance to y attribute of next sprite
* Shadow
       li   r0,ashadw+spratt
       ab   r4,*r0
       ab   r5,*r0+                            ; Add to y
       ab   r3,*r0
       ab   r5,*r0+                            ; Add to x
       movb r2,*r0                             ; Set pattern
* Record height
       sra  r5,8                               ; Height change
       a    r5,@jmpz                           ; Add to total height
* Clear scroll adjustment variables
       clr  @movdxv
       clr  @movdyv
       jmp  movba2
* Animate when died
movbae:
       srl  r1,2
       ci   r1,11
       jgt  movbaf
       sla  r1,1
       ai   r1,diepat
       li   r0,spratt+aball+2                  ; Address of pattern attribute in CPU RAM
       movb *r1+,*r0
       ai   r0,4
       movb *r1,*r0
       li   r0,spratt+ashadw
       mov  @spratt+aball,*r0+                 ; Place shadow directly under ball
       movb *r1,*r0
       li   r1,1
       bl   @decnrg
       jmp  movba2
movbaf:
       seto @died
* Next animation frame
movba2:
       inc  @jmpfrm
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // MOVBAL

***************************************************************************
* 
* Move enemies
* 
movenm:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>070c
       bl   @vwtr
       .endif 
       li   r3,enmlst                          ; Pointer to enemy list
moven1:
       mov  *r3,r4                             ; Get first word of enemy structure
       jne  movenf
       b    @moven9                            ; Zero terminates list
* Check y position
movenf:
       mov  @enm_y(r3),r4                      ; Get y position in map coordinates
       s    @scrly,r4                          ; Subtract scroll position to get screen coordinate
       ai   r4,-y_diff                         ; Adjustment
       ci   r4,-16                             ; Check if above screen
       jlt  movenz
       ci   r4,191                             ; Check if below screen
       jgt  movenz
       jmp  movenx
movenz:
       b    @moven4
* Check x position
movenx:
       mov  @enm_x(r3),r5                      ; Get x position
       ci   r5,0                               ; Check if off left
       jlt  moven4
       ci   r5,256-80                          ; Check if off right
       jgt  moven4
* Check if sprite allocated
       mov  @enm_at(r3),r0                     ; Get attributes address
       jne  moven3                             ; Jump if already allocated
* Allocate sprite
       li   r0,spratt+aenemy
       li   r2,nenemy
moven2:
       cb   @bytec0,*r0
       jne  moven6
* Found one
       mov  r0,@enm_at(r3)                     ; Save attribute address
       jmp  moven3
moven6:
       ai   r0,8
       dec  r2
       jne  moven2
* Cannot allocate sprite
       jmp  moven7                             ; Next enemy
* Pattern
moven3:
       mov  @frame,r6
       andi r6,>0018
       a    @enm_pt(r3),r6
* Color
       mov  @enm_cl(r3),r7                     ; Color
* Write attributes
       swpb r4
       swpb r5
       swpb r6
       movb r4,*r0+                            ; Write y attribute
       movb r5,*r0+                            ; Write x attribute
       movb r6,*r0+                            ; Write pattern attribute
       movb r7,*r0+                            ; Color
       ai   r6,>0400
       movb r4,*r0+                            ; Write y attribute
       movb r5,*r0+                            ; Write x attribute
       movb r6,*r0+                            ; Write pattern attribute
       movb @r7lb,*r0+                         ; Color
* Movement
       dec  @enm_ct(r3)                        ; Count down to movement
       jne  moven7
       li   r0,4
       mov  r0,@enm_ct(r3)                     ; Reset counter
       mov  @enm_dx(r3),r7                     ; dx
       mov  @enm_dy(r3),r8                     ; dy
* Check type
       c    @one,@enm_tp(r3)                   ; Check if type if bounded
       jne  moven5
* Bounded - check bounds
       swpb r5                                 ; Move x to LSB
       mov  r5,r0                              ; x
       swpb r4                                 ; Move y to LSB
       mov  r4,r1                              ; y
       mov  r7,r7                              ; Test dx
       jeq  movenb
       jlt  movena
       ai   r0,16                              ; dx>0: one metatile offset if moving right
movena:
       a    r7,r0                              ; dx<>0. x + dx
       jmp  moveng
movenb:
       ai   r0,8                               ; dx=0: x+=8 (center x)
moveng:
       mov  r8,r8                              ; Test dy
       jeq  movend
       jlt  movenc
       ai   r1,16                              ; dy>0: one metatile offset if moving down
movenc:
       a    r8,r1                              ; dy<>0: y + dy
       jmp  movenh
movend:
       ai   r1,8                               ; dy=0: y+=8 (center y)
movenh:
       bl   @getmt                             ; Get metatile at R0,R1
** On return r0=meta tile, r1=map address
       ci   r0,mttile                          ; Check if moving on tile
       jeq  moven5
* Change velocity 90 degress
       bl   @rand                              ; Let chance decide which way to turn
       jlt  moven8
       neg  r7                                 ; -dx (turn left)
* Check new position
moven8:
       mov  r5,r0                              ; x
       mov  r4,r1                              ; y
       mov  r8,r8                              ; Test dy
       jeq  moveni
       a    r8,r0                              ; x + dy
       jmp  movenj
moveni:
       ai   r0,8                               ; Center x
movenj:
       mov  r7,r7                              ; Text dx
       jeq  movenk
       a    r7,r1                              ; y +/- dx
       jmp  movenl
movenk:
       ai   r1,8                               ; Center y
movenl:
       bl   @getmt
       ci   r0,mttile                          ; Check if moving on tile
       jeq  movene
* Go with other direction
       neg  r7
* Swap dx and dy
movene:
       mov  r7,r9                              ; tmp=dx
       mov  r8,r7                              ; dx=dy
       mov  r9,r8                              ; dy=tmp
       mov  r7,@enm_dx(r3)                     ; Write dx (= dy)
       mov  r8,@enm_dy(r3)                     ; Write dy  (= +/-dx)
* Move
moven5:
       a    r7,@enm_x(r3)                      ; x += dx
       a    r8,@enm_y(r3)                      ; y += dy
       jmp  moven7
* Disable
moven4:
       mov  @enm_at(r3),r0                     ; Get attributes address
       jeq  moven7                             ; Jump if not allocated
       mov  @bytec0,*r0+                       ; Move out of screen
       inct r0
       mov  @bytec0,*r0+                       ; Move out of screen
       clr  @enm_at(r3)                        ; Deallocate sprite
* Next enemy
moven7:
       ai   r3,enm_sz
       b    @moven1
* Return
moven9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // MOVENM

***************************************************************************
* 
* Display sparkle sprites
* 
sparkl:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>070d
       bl   @vwtr
       .endif 
       mov  @frame,r0                          ; Only run very 4th frame
       andi r0,3
       jne  spark4
       clr  r0
       li   r1,spratt+aspark                   ; Attribute pointer
       li   r2,nspark                          ; Counter
spark1:
       cb   @bytec0,*r1                        ; Check for out of screen
       jeq  spark2                             ; Skip if so
       movb @2(r1),r0                          ; Read the current pattern
       ci   r0,pxball*256                      ; Check if it's a gift
       jhe  spark6
       ai   r0,>0100                           ; Add one to the pattern
       ci   r0,(pspark+16)*256                 ; Check if it's the last one
       jeq  spark3
       movb r0,@2(r1)                          ; Set pattern
       li   r0,>0100                           ; y offset
       ab   r0,*r1                             ; Move y
       jmp  spark2                             ; Next
* Done with sparkles
spark3:
       mov  @pgift,r3                          ; Get gift pattern and color
       ci   r3,16                              ; If no gift or another gift visible
       jle  spark5                             ; then remove the sprite
       mov  r3,@2(r1)                          ; Set gift pattern and color
       li   r3,16                              ; Number of frame where gift will be visible
       mov  r3,@pgift                          ; Set counter
       jmp  spark2
* Count down while displaying gift pattern
spark6:
       li   r0,>0100                           ; y offset
       ab   r0,*r1                             ; Move y
* MOV  @PGIFT,r0
* ANDI r0,>000F
* SWPB r0
* MOVB r0,@3(r1)
       dec  @pgift                             ; Decrement counter
       jne  spark2
* Remove sprite
spark5:
       movb @bytec0,*r1
* Next sprite
spark2:
       ai   r1,4
       dec  r2
       jne  spark1
* Return
spark4:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SPARKL

***************************************************************************
* 
* Check for quit
* 
ckquit:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>07e
       bl   @vwtr
       .endif 
       clr  r1                                 ; Test column 0
       li   r12,>0024                          ; Address for column selection
       ldcr r1,3                               ; Select column
       li   r12,>0006                          ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Quit
quit:
       blwp @>0000

***************************************************************************
* 
* Set name table
* 
* Altenate between tables 0 and 1 in frames 0-7
* Alternate between tables 2 and 3 in frames 8-15
* 
* Tables 0 and 2 contain 'names' from the low character set (0-127)
* Tables 1 and 3 contain 'names' from the high character set (128-255)
* 
* Modifies r0
* 
setnt:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @scrly,r0                          ; Get scroll offset
       coc  @eight,r0                          ; Check which table set to use
       jeq  setnt2
       coc  @one,r0                            ; Check which table to use
       jeq  setnt1
       li   r0,>020a                           ; NAMET0
       jmp  setnt4
setnt1:
       li   r0,>020b                           ; NAMET1
       jmp  setnt4
setnt2:
       coc  @one,r0                            ; Check which table to use
       jeq  setnt3
       li   r0,>020c                           ; NAMET2
       jmp  setnt4
setnt3:
       li   r0,>020d                           ; NAMET3
* Update register 2
setnt4:
       bl   @vwtr
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SETNT

***************************************************************************
* 
* Update pattern and color tables
* 
* Alternate between updating low (0-127) or high (128-255) half of
* the character set. The set that is updated is not used (and therefore
* not visible) in the currently displayed name table. This provides the
* desired double buffering effect.
* 
* Modifies r0-r3
* 
updpt:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @scrlyo,r3                         ; Get old scroll offset
* Calculate VDP RAM destination address
       coc  @one,r3                            ; Check which character set to update
       jeq  updpt1
       li   r0,ptrntb+>400                     ; Update high character set (128-255)
       jmp  updpt2
updpt1:
       li   r0,ptrntb                          ; Update low character set (128-255)
* Calculate CPU RAM source address
updpt2:
       li   r1,7                               ; Start with last frame
       s    r3,r1                              ; Subtract scroll frame
       inc  r1                                 ; Adjust for direction
       andi r1,>0007                           ; Mod 8
       mpy  @stlnum,r1                         ; Multiply by number of patterns
       mov  r2,r1                              ; Get result back
       sla  r1,3                               ; 8 bytes per pattern
       ai   r1,ptfrm0
* Use the value of the scroll counter SCRLCT
* to determine which tables to update this frame
       mov  @scrlct,r2                         ; Get scroll counter
       sla  r2,1                               ; Convert to word offset
       mov  @jmptbl(r2),r2                     ; Get address from jump table
       b    *r2                                ; Branch
* Scroll counter 0         * 1st pattern table
updpt3:
       mov  @stlnu2,r2                         ; First 2/3 of patterns
       bl   @vm8bw
       jmp  updpt9
* Scroll counter 1
updpt4:
       ai   r0,>800                            ; 2nd pattern table
       mov  @stlnu2,r2                         ; First 2/3 of patterns
       bl   @vm8bw
       jmp  updpt9
* Scroll counter 2
updpt5:
       ai   r0,>1000                           ; 3rd pattern table
       mov  @stlnu2,r2                         ; First 2/3 of patterns
       bl   @vm8bw
       jmp  updpt9
* Scroll counter 3
updpt6:
       ai   r0,colrtb                          ; Color table
       ai   r1,clfrm0-ptfrm0                   ; Add offset between patterns and colors
       mov  @stlnu2,r2                         ; First 2/3 of patterns
       bl   @vm8bw
       jmp  updpt9
* Scroll counter 4
updpt7:
       mov  @stlnu3,r2                         ; Last 1/3 of pattern 1,2
       jeq  updpt9                             ; No more
       mov  @stlnu2,r3
       sla  r3,3                               ; Offset to last 1/3
       a    r3,r0                              ; Add to destination
       a    r3,r1                              ; Add to source
       mov  r0,r4
       mov  r1,r5
       bl   @vm8bw                             ; 1st pattern table
       mov  r4,r0
       ai   r0,>800                            ; 2nd pattern table
       mov  r5,r1
       mov  @stlnu3,r2                         ; Last 1/3
       bl   @vm8bw
       jmp  updpt9
* Scroll counter 5
updpt8:
       mov  @stlnu3,r2                         ; Last 1/3
       jeq  updpt9                             ; No more
       mov  @stlnu2,r3
       sla  r3,3                               ; Offset to last 1/3
       a    r3,r0                              ; Add to destination
       a    r3,r1                              ; Add to source
       mov  r0,r4
       mov  r1,r5
       ai   r0,>1000                           ; 3nd pattern table
       bl   @vm8bw
       mov  r4,r0
       ai   r0,colrtb                          ; Color table
       mov  r5,r1
       ai   r1,clfrm0-ptfrm0                   ; Add offset between patterns and colors
       mov  @stlnu3,r2                         ; Last 1/3
       bl   @vm8bw
* Return
updpt9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Jump table
jmptbl:
       data updpt3,updpt4,updpt5,updpt6,updpt7,updpt8
* // UPDPT

***************************************************************************
* 
* Update name table off-screen buffer
* 
* The prepared buffers have a one row (8 pixels) offset from
* from the currently visible buffers.
* 
* Altenate between updating table buffers 2 and 3 in frames 0-7
* Alternate between updating table buffers 0 and 1 in frames 8-15
* 
* Since we have 8 frames to update two buffers we need to update
* 1/4 buffer each frame, i.e. 6 screen rows. First frame we update
* rows 0-5 of the first buffer. Second frame we update the same 6
* rows of the second buffer, but this time we set the most significant
* bit to use the high character set. Third frame we update rows 6-11
* of the first buffer, and so on.
* 
* Because is this case we only scroll every 6th frame (according to
* when @SCRLCT is zero) we only have to update 1/6 of the usual, i.e.
* one row each time the routine is called. The scroll counter offset
* is used to determine which row to update.
* 
* Modifies r0-r4
* 
updnt:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @scrlct,r4                         ; Get scroll counter 5,4,3,2,1,0
       .ifne anympw
       mov  r4,r5
       mpy  @m_mapw,r5                         ; map scroll counter offset = scroll counter * mapw
       mov  r6,r5
       sla  r4,5                               ; screen scroll counter offset = scroll counter * 32
       .else 
       sla  r4,5                               ; screen scroll counter offset = scroll counter * 32
       mov  r4,r5                              ; Map scroll counter offset = Screen scroll counter offset
       .endif 
       mov  @scrly,r3                          ; Get scroll position
       andi r3,>000f                           ; Frame = position mod 16
* Calculate row offset to the 1/4 of the buffer to update
       mov  r3,r0                              ; Start with frame number
       andi r0,>0006                           ; Transform to sequence: 0,0,2,2,4,4,6,6...
       mov  r0,r2                              ; Copy to R2
       sla  r0,1                               ; Multiply by 2
       a    r0,r2                              ; Add to R2 to multiply by 3 and get row offset: 0,0,6,6,12,12,18,18...
       mov  r2,r0                              ; Copy back into R0 for later
* Calculate map source address in r1
       mov  @scrly,r1                          ; Get scroll offset in pixels
       srl  r1,3                               ; Divide by 8 to get row offset
       dec  r1                                 ; Prepared buffer has a 1 row offset
       a    r2,r1                              ; Add the row offset we calculated before
       .ifne anympw
       mpy  @m_mapw,r1                         ; Multiply by MAPW to get character offset
       .else 
       sla  r1,5                               ; Multiply by 32 to get character offset
       mov  r1,r2                              ; Copy to R2
       .endif 
       li   r1,map                             ; Get the map base address
       a    r2,r1                              ; Add the character offset
       a    r5,r1                              ; Add map scroll counter offset
       .ifne hscrl
       a    @scrlx,r1                          ; Add x scroll offset
       .endif 
* Calculate buffer destination address in r0
       sla  r0,5                               ; Convert row offset to screen character offset
       a    r4,r0                              ; Add screen scroll counter offset
* Decide which buffer to update
       coc  @eight,r3                          ; Bit weight >08 determines the group
       jne  updnt2                             ; If not set we update buffer 2 or 3
       coc  @one,r3                            ; Bit weight >01 determines the buffer
       jeq  updnt1
       ai   r0,namet0                          ; Add base address to character offset
       jmp  updnt4
updnt1:
       ai   r0,namet1                          ; Add base address to character offset
       jmp  updnt4
updnt2:
       coc  @one,r3                            ; Bit weight >01 determines the buffer
       jeq  updnt3
       ai   r0,namet2                          ; Add base address to character offset
       jmp  updnt4
updnt3:
       ai   r0,namet3                          ; Add base address to character offset
* Copy to VDP RAM buffer
updnt4:
       li   r2,vieww/8                         ; Number of 8 character groups to copy
       coc  @one,r3                            ; High or low character set copy?
       jeq  updnt5
       bl   @vm8bw                             ; Low character set
       jmp  updnt6
updnt5:
       bl   @vm8bhw                            ; High character set
* Return
updnt6:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // UPDNT

***************************************************************************
* 
* Set graphics mode
* 
gmode:
       mov  r11,*r10+                          ; Push return address onto the stack
       clr  r0
       li   r1,vregs
       li   r2,8
gmode1:
       movb *r1+,@r0lb
       bl   @vwtr                              ; Set register
       ai   r0,>0100
       dec  r2
       jne  gmode1
* Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
* Initialize the Color Table
       li   r0,colrtb
       li   r1,>f000                           ; White pixels on transparent background
       li   r2,>800
       bl   @vsmw
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
vregs:
       byte >02                                ; Graphics II mode
       byte >e2                                ; 16K, display on, interrupt enabled
       byte >0d                                ; NAMETB = >3400
       byte >9f                                ; COLRTB = >2000, >800 bytes
       byte >03                                ; PTRNTB = >0000, >1800 bytes
       byte >3f                                ; SPRATB = >1F80
       byte >03                                ; SPRPTB = >1800
       byte >00                                ; Backdrop color
* // GMODE

***************************************************************************
* 
* Unpack meta tile map from nybbles to bytes
* 
* r0: Source address of compressed meta tile map
* r1: Destination address of unpacked map
* 
unpack:
       li   r2,mapw*maph/16
unpac1:
       mov  *r0+,r4
       li   r3,4
unpac2:
       mov  r4,r5
       andi r5,>f000
       srl  r5,4
       movb r5,*r1+
       sla  r4,4
       dec  r3
       jne  unpac2
       dec  r2
       jne  unpac1
* Return
       b    *r11
* // EXPMAP

***************************************************************************
* 
* Expand meta tile map
* 
* r0: Address of meta tile map
* r1: Address of meta tile list (each entry 4 bytes)
* 
* On return the map is expanded to address MAP.
* 
expmap:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r4,map                             ; Destination address
       li   r3,maph/2                          ; Meta row counter
expma1:
       li   r2,mapw/2                          ; Meta column counter
expma2:
       clr  r5
       movb *r0+,r5                            ; Get meta tile number
       srl  r5,6                               ; Convert to offset in list
       a    r1,r5                              ; Add list base address
       mov  *r5+,*r4+                          ; Write 2 even row bytes
       mov  *r5,@mapw-2(r4)                    ; Write 2 odd row bytes
       dec  r2                                 ; Meta column counter
       jne  expma2
       ai   r4,mapw                            ; Advance destination one row
       dec  r3                                 ; Meta row counter
       jne  expma1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // EXPMAP

***************************************************************************
* 
* Initialize the scroll tile map
* and update the tile maps to contain scroll tile entries
* 
* On return MAP has been updated
* and @STLNUM contains the number of scroll tiles
* 
inist:
       mov  r11,*r10+                          ; Push return address onto the stack
* Save next MAPW bytes after map
* LI   r0,ROWBUF
* LI   r1,MAPE
* LI   r2,MAPW
* BL   @COPY
* Repeat first row after last row
       li   r0,mape                            ; Repeat first row after last row
       li   r1,map                             ; to allow correctly wrapping scroll
       li   r2,mapw                            ; tiles to be calculated for last row
       bl   @copy
* Main routine
       clr  r0                                 ; R0 is the index of the highest scroll tile
       li   r1,map                             ; R1 is the address in the tile map
       li   r2,mape-map                        ; R2 is number of tiles to update
inist1:
       movb *r1,r3                             ; Get 'scroll to' tile
       swpb r3                                 ; R3 LSB is index of 'scroll to' tile
       movb @mapw(r1),r3                       ; R3 MSB is index of 'scroll from' tile
       li   r4,stiles                          ; R4 is the address in the scroll tile map
       clr  r5                                 ; R5 is index of currently checked scroll tile
inist2:
       c    r5,r0                              ; Check if last existing scroll tile is reached
       jeq  newst
       c    *r4,r3                             ; Check if scroll tile exists
       jeq  oldst
       inct r4                                 ; Next word
       inc  r5                                 ; Next index
       jmp  inist2
oldst:
       swpb r5
       movb r5,*r1                             ; Update tile map
       swpb r5
       jmp  inist3
newst:
       swpb r0
       movb r0,*r1                             ; Update tile map
       mov  r3,*r4                             ; Create new scroll tile entry
       swpb r0
       inc  r0                                 ; Next scroll tile
       inct r4
inist3:
       inc  r1                                 ; Next tile in map
       dec  r2                                 ; Decrement counter
       jne  inist1
* Save number of tiles
       mov  r0,@stlnum                         ; Save number of tiles
       mov  r0,r1                              ; Dividend
       clr  r0                                 ; Prepare for division
       li   r2,3                               ; Divisor
       div  r2,r0                              ; Divide by 3
       mov  r0,r2                              ; Copy quotient
       sla  r2,1                               ; 2/3 of tiles
       mov  r2,@stlnu2                         ; Save it
       a    r1,r0                              ; Add remainder to last 1/3
       mov  r0,@stlnu3                         ; Save it
* Restore next MAPW bytes after map
* LI   r0,MAPE
* LI   r1,ROWBUF
* LI   r2,MAPW
* BL   @COPY
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // INIST

***************************************************************************
* 
* Pre-scroll scroll tiles into 8 frames of increasing scroll offset
* 
* r1: Destination address
* r0: Base tile pattern/color address
* 
pscrl:
       mov  r11,*r10+                          ; Push return address onto the stack
       clr  r7                                 ; R7 is the scroll offset/frame (0-7)
pscrl0:
       li   r2,stiles                          ; R2 is the address in the scroll tile map
       clr  r6                                 ; R6 is index of current scroll tile
pscrl1:
       mov  *r2,r3                             ; R3 contains indices of from/to tiles
       mov  r7,r7                              ; Check for 0 offset
       jeq  pscrl3                             ; Skip 'scroll to' tile if offset is 0
       mov  r3,r4                              ; R4 LSB is index of 'scroll to' tile
       andi r4,>00ff                           ; Clear MSB
       sla  r4,3                               ; Multiply by 8
       ai   r4,8                               ; Add 8
       s    r7,r4                              ; Minus offset
       a    r0,r4                              ; Add base address of CPU RAM patterns
       mov  r7,r5                              ; Copy 'offset' bytes
pscrl2:
       movb *r4+,*r1+                          ; Copy byte
       dec  r5                                 ; Decrement counter
       jne  pscrl2
pscrl3:
       swpb r3
       mov  r3,r4                              ; R4 LSB is index of 'scroll from' tile
       andi r4,>00ff                           ; Clear MSB
       sla  r4,3                               ; Multiply by 8
       a    r0,r4                              ; Add base address of CPU RAM patterns
       li   r5,8                               ; Copy 8 bytes
       s    r7,r5                              ; Minus scroll offset
pscrl4:
       movb *r4+,*r1+                          ; Copy byte
       dec  r5                                 ; Decrement counter
       jne  pscrl4                             ; Loop
       inct r2                                 ; Next word in scroll tile map
       inc  r6                                 ; Next scroll tile
       c    r6,@stlnum                         ; Check if all tiles done
       jne  pscrl1
       ai   r0,8*32
       inc  r7                                 ; Next offset/frame
       ci   r7,8                               ; Check if last frame
       jne  pscrl0
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // PSCRL

***************************************************************************
* 
* Display initial screen
* 
* Note that the pattern frame that should be uploaded here depends on the
* initial direction of the scrolling. If we want ot start at the bottom and
* scroll up, VPFRM0 should be loaded instead, and @SCRLY should be initilized
* so that the four least significant bits are all ones, e.g. 511.
* 
iniscr:
       mov  r11,*r10+                          ; Push return address onto the stack
* Upload patterns part 1
       li   r0,ptrntb                          ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
       li   r0,ptrntb+>400                     ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
* Upload patterns part 2
       li   r0,ptrnt1                          ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
       li   r0,ptrnt1+>400                     ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
* Upload patterns part 3
       li   r0,ptrnt2                          ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
       li   r0,ptrnt2+>400                     ; Destination address in VDP RAM
       li   r1,ptfrm0                          ; Address of last scrolled pattern frame
       mov  @stlnum,r2                         ; Number of patterns of 8 bytes
       bl   @vm8bw                             ; Call copying routine
* Upload colors
       li   r0,colrtb                          ; Destination address in VDP RAM
       li   r1,clfrm0                          ; Address of last scrolled color frame
       mov  @stlnum,r2                         ; Number of pattern colors of 8 bytes
       bl   @vm8bw                             ; Call copying routine
       li   r0,colrtb+>400                     ; Destination address in VDP RAM
       li   r1,clfrm0                          ; Address of last scrolled color frame
       mov  @stlnum,r2                         ; Number of pattern colors of 8 bytes
       bl   @vm8bw                             ; Call copying routine
* Init name tables
       mov  @scrly,r4                          ; Get initial scroll offset in pixels
       srl  r4,3                               ; Convert to row offset
       .ifne anympw
       li   r3,mapw
       mpy  r4,r3
       .else 
       sla  r4,5                               ; Convert to character offset
       .endif 
       .ifne hscrl
       a    @scrlx,r4                          ; Add x scroll offset
       .endif 
* Table 0
       li   r0,namet0                          ; Destination address in VDP RAM
       li   r1,map-mapw                        ; Base address of map data
       a    r4,r1                              ; Add character offset
       clr  r5
       bl   @dspscr                            ; Display screen
* Table 1
       li   r0,namet1                          ; Destination address in VDP RAM
       li   r1,map-mapw                        ; Base address of map data
       a    r4,r1                              ; Add character offset
       seto r5
       bl   @dspscr                            ; Display screen
* Table 2
       li   r0,namet2                          ; Destination address in VDP RAM
       li   r1,map                             ; Base address of map data
       a    r4,r1                              ; Add character offset
       clr  r5
       bl   @dspscr                            ; Display screen
* Table 3
       li   r0,namet3                          ; Destination address in VDP RAM
       li   r1,map                             ; Base address of map data
       a    r4,r1                              ; Add character offset
       seto r5
       bl   @dspscr                            ; Display screen
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // INISCR

***************************************************************************
* 
* Look for switch and initialize update of meta tiles
* 
* r1: Meta tile map offset of potential trigger
* 
switch:
       mov  r11,*r10+                          ; Push return address onto the stack
* Calculate coordinates of offset
       ai   r1,-mtmap                          ; Subtract base address
       clr  r0
       li   r3,mapw/2
       div  r3,r0                              ; R0 is Meta tile row number (y), R1 is column number (x)
       swpb r1                                 ; Move column to MSB
       soc  r0,r1                              ; Combine with LSB in R1
* Look for coordinates in list
       li   r0,swlist                          ; List of switches
switc1:
       mov  *r0+,r2                            ; Get switch coordinates
       jeq  switc3                             ; Zero terminates list
       c    r1,r2                              ; Check if coordinates match position
       jne  switc2
* Found switch, record the address of tile list
       mov  *r0+,@mtswtl                       ; Record which tile number to use
       mov  *r0,@mtswpt                        ; Record address of tiles
       seto r0
       li   r0,connec
       bl   @speak                             ; Say something
       jmp  switc4
switc2:
       ai   r0,4
       jmp  switc1
switc3:
       clr  r0
* Return
switc4:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SWITCH

***************************************************************************
* 
* Update switched meta tiles
* 
updsmt:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0705
       bl   @vwtr
       .endif 
       mov  @mtswpt,r0                         ; Get pointer to meta tile list
       jeq  updsm2                             ; Return if not set
       mov  *r0,r1                             ; Get meta tile coordinates
       jeq  updsm1                             ; Zero terminates list
       mov  @mtswtl,r0                         ; Get tile to use
       bl   @setmtp
       inct @mtswpt
       jmp  updsm2
updsm1:
       clr  @mtswpt
* Return
updsm2:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SWITCH

***************************************************************************
* 
* Display screen
* 
* r0: Destination
* r1: Source
* r5: High character flag
* 
dspscr:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r6,viewh                           ; Rows
dspsc1:
       mov  r0,r7
       li   r2,vieww/8                         ; Columns / 8
       abs  r5
       jne  dspsc2
       bl   @vm8bw
       jmp  dspsc3
dspsc2:
       bl   @vm8bhw
dspsc3:
       mov  r7,r0
       ai   r0,scrnw                           ; Next screen row
       ai   r1,mapw-vieww
       dec  r6
       jne  dspsc1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DSPSCR

***************************************************************************
* 
* Get the meta tile at the specified screen position
* 
* r0: x position (pixels)
* r1: y position (pixels)
* 
* On return r0 contains the meta tile number and r1 the map address.
* 
getmt:
       mov  r11,*r10+                          ; Push return address onto the stack
       a    @scrly,r1                          ; Add scroll offset to y
       ai   r1,y_diff                          ; Adjustment
       .ifne anympw
       srl  r1,4                               ; Divide by 16 to find row number
       li   r2,mapw/2
       mpy  r2,r1                              ; Multiply to MAPW to find row offset
       mov  r2,r1
       .else 
       andi r1,>fff0                           ; Row offset
       .endif 
       srl  r0,3                               ; Offset into row (characters)
       .ifne hscrl
       a    @scrlx,r0                          ; Add x scroll offset
       .endif 
       srl  r0,1                               ; Offset in meta tiles
       a    r0,r1                              ; Map offset
       ai   r1,mtmap                           ; Add base address
       clr  r0
       movb *r1,@r0lb                          ; Get meta tile
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // GETMT

***************************************************************************
* 
* Set meta tile at specified map coordinates
* 
* r0: Meta tile number to set
* r1: Map coordinates x,y in MSB,LSB
* 
setmtp:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r1,r3                              ; Save x
       andi r1,>00ff                           ; y
       li   r2,mapw/2                          ; Map width in meta tiles
       mpy  r2,r1                              ; y * w in r2
       srl  r3,8                               ; x
       a    r3,r2                              ; x + y * w
       mov  r2,r1                              ; Map offset
       ai   r1,mtmap                           ; Add base address
       bl   @setmt
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // SETMTP

***************************************************************************
* 
* Set the meta tile at the specified address
* 
* r0: Meta tile number to set
* r1: Meta tile map address
* 
* On return MTMAP and MAP has been updated
* 
nw:
       equ  0
ne:
       equ  1
sw:
       equ  2
se:
       equ  3

setmt:
       mov  r11,*r10+                          ; Push return address onto the stack
* Update meta tile map
       movb @r0lb,*r1
* Get meta tile numbers from map
       clr  r3
       movb @-mapw/2(r1),r3                    ; Meta tile number above
       swpb r3
       mov  r0,r4                              ; Meta tile number middle
       clr  r5
       movb @mapw/2(r1),r5                     ; Meta tile number below
       swpb r5
* Get pointers to tile numbers
       sla  r3,2                               ; Multiply by 4 (4 tiles per meta tile)
       ai   r3,mtiles                          ; Add base of meta tile definitions list
       sla  r4,2                               ; Multiply by 4
       ai   r4,mtiles                          ; Add base of meta tile definitions list
       sla  r5,2                               ; Multiply by 4
       ai   r5,mtiles                          ; Add base of meta tile definitions list
* Destination address in MAP
       ai   r1,-mtmap                          ; Offset into meta tile map
       .ifne anympw
       clr  r6
       mov  r1,r7                              ; Offset into meta tile map
       li   r8,mapw/2
       div  r8,r6                              ; R6 is Meta tile row number, R7 is column number
       mov  r7,r9                              ; Save the column
       mpy  r8,r6                              ; Meta tile offset at start of row in R7
       sla  r7,2                               ; Character offset at start of row
       mov  r7,r6
       sla  r9,1                               ; Multiply column by 2 to get character offset
       a    r9,r6                              ; Add to row offset to get offset into MAP
       .else 
       mov  r1,r6                              ; Offset into meta tile map
       andi r6,>fff0                           ; Meta tile offset at start of row
       sla  r6,2                               ; Multiply by 4 to get character offset
       andi r1,>000f                           ; Meta tile offset into row
       sla  r1,1                               ; Multiply by 2 to get character offset
       a    r1,r6                              ; Add to get offset into MAP
       .endif 
       ai   r6,map-mapw                        ; Add base address, one row up
* Destination address/offset in VDP RAM
       mov  r6,r7
       ai   r7,-map                            ; Back to offset
       mov  @scrly,r0                          ; Scroll offset
       srl  r0,3                               ; Scroll offset in rows
       .ifne anympw
       mpy  @m_mapw,r0                         ; Scroll offset in map characters in R1
       mov  r7,r8
       s    r1,r8                              ; offset from top of screen *in map characters*
       jlt  setmt6
       clr  r7
       div  @m_mapw,r7                         ; r7 has row, r8 has column *** note: doesn't work if r8 was negative
       sla  r7,5                               ; Multiply by screen width
       a    r8,r7                              ; Add column
       .else 
       sla  r0,5                               ; Scroll offset in characters
       s    r0,r7                              ; Offset from top of screen
       jlt  setmt6
       .endif 
       mov  r7,r8                              ; Make a copy for visible buffer
       ai   r7,scrnw                           ; Off-screen buffer is scrolled one row
       .ifne hscrl
       s    @scrlx,r7                          ; Subtract x scroll offset
       .endif 
       ai   r7,namet0                          ; Add offset to name table buffer
       .ifne hscrl
       s    @scrlxv,r8                         ; Subtract visible x scroll offset
       .endif 
       mov  r8,@mtoffs                         ; Save for later
       ai   r8,namet2                          ; Visible buffers
       mov  @scrly,r0
       coc  @eight,r0                          ; Check which buffers to use
       jeq  setmt1
       ai   r7,namet2-namet0                   ; Use second set of buffers in frames 0-7
       ai   r8,namet0-namet2
       jmp  setmt1
* Negative offset from top
setmt6:
       seto @mtoffs
       li   r7,>8000
       li   r8,>8000
**
* Lookup scroll tile and write to MAP (top-left)
setmt1:
       movb @sw(r3),@r0lb
       movb @nw(r4),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Lookup scroll tile and write to MAP (top-right)
       movb @se(r3),@r0lb
       movb @ne(r4),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Next row
       ai   r6,mapw-2                          ; Next row
       ai   r7,30
       ai   r8,30
* Lookup scroll tile and write to MAP (middle-left)
       movb @nw(r4),@r0lb
       movb @sw(r4),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Lookup scroll tile and write to MAP (middle-right)
       movb @ne(r4),@r0lb
       movb @se(r4),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Next row
       ai   r6,mapw-2                          ; Next row
       ai   r7,30
       ai   r8,30
* Lookup scroll tile and write to MAP (bottom-left)
       movb @sw(r4),@r0lb
       movb @nw(r5),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Lookup scroll tile and write to MAP (bottom-right)
       movb @se(r4),@r0lb
       movb @ne(r5),r0
       bl   @findst
       movb r1,*r6+
* Write to VDP off-screen buffer
       bl   @setmt2
* Write to VDP visible buffer
       bl   @setmt3
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Write to VDP off-screen buffer (address in r7, byte in r1)
setmt2:
       mov  r11,*r10+                          ; Push return address onto the stack
       coc  @w300h,r7                          ; Check of out of screen
       jeq  setmt4
       mov  r7,r0
       jlt  setmt4
       andi r1,>7fff                           ; Clear msb
       bl   @vsbw
       ai   r0,namet1-namet0                   ; Next table buffer
       ori  r1,>8000                           ; Set msb
       bl   @vsbw
setmt4:
       inc  r7
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Write to VDP visible buffer (address in r8, byte in r1)
setmt3:
       mov  r11,*r10+                          ; Push return address onto the stack
       coc  @w300h,r8                          ; Check of out of screen
       jeq  setmt5
       mov  r8,r0
       jlt  setmt5
       andi r1,>7fff                           ; Clear msb
       bl   @vsbw
       ai   r0,namet1-namet0                   ; Next table buffer
       ori  r1,>8000                           ; Set msb
       bl   @vsbw
setmt5:
       inc  r8
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
w300h:
       data >0300
* // SETMT

***************************************************************************
* 
* Find scroll tile
* 
* r0: From/to tile numbers to look up
* 
* On return r1 MSB contains the scroll tile number, or -1 if not found
* 
findst:
       li   r1,stiles                          ; Address of scroll tile definition list
       mov  @stlnum,r2                         ; Number of scroll tiles
finds1:
       c    r0,*r1+                            ; Check list entry
       jeq  finds2                             ; Found
       dec  r2
       jne  finds1
* Not found
       seto r1
       jmp  finds3
* Found
finds2:
       ai   r1,-stiles-2                       ; Offset into list
       srl  r1,1                               ; Index in list
       swpb r1
* Return
finds3:
       b    *r11
* // FINDST

***************************************************************************
* 
* Intialize sparkle
* 
ispark:
       mov  r11,*r10+                          ; Push return address onto the stack
* Find a sprite to use
       li   r1,spratt+aspark                   ; Attribute
       li   r2,nspark                          ; Counter
ispar1:
       cb   @bytec0,*r1                        ; Check if parked outside screen
       jeq  ispar2
       ai   r1,4                               ; Next sprite
       dec  r2
       jne  ispar1
       jmp  ispar3
* Found sprite
ispar2:
       mov  @mtoffs,r0                         ; Get screen offset
       jlt  ispar3
       mov  r0,r3
       srl  r3,5                               ; Rows
       sla  r3,3                               ; y
       swpb r3
       andi r0,>001f                           ; Columns
       sla  r0,3                               ; x
       soc  r3,r0                              ; Combine y and x
       mov  r0,*r1+
       li   r0,pspark*256+10                   ; Pattern + color yellow
       mov  r0,*r1
* Return
ispar3:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // ISPARK

***************************************************************************
* 
* Handle question mark tile
* 
* r1: meta tile address
* 
* Specials triggered by question mark
* - Bonus points
* - Restore energy
* - Extra life
* - Double jump (time limited condition)
* - Immunity (time limited condition)
* - Confusion / inverse movement (time limited condition)
* 
questm:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r1,@qstmpa                         ; Save map address
       li   r0,mttile                          ; Change to tile
       bl   @setmt                             ; Set the meta tile
       bl   @ispark                            ; Init sparkle
       mov  @qstmpa,r1                         ; Restore map address
* JMP  QUEST6              * Test specific condition
       bl   @switch                            ; Check if tile is switching other tiles
       mov  r0,r0                              ; A non-zero return value
       jne  quest9                             ; means that it was a trigger
* Handle other specials
       bl   @rand                              ; Call random routine
       ci   r0,>2000
       jl   quest1                             ; Double jump [>0000 - >2000[
       ci   r0,>4000
       jl   quest6                             ; Double jump [>2000 - >4000[
       ci   r0,>8000
       jl   quest2                             ; Immunity [>4000 - >8000[
       ci   r0,>9000
       jl   quest3                             ; Confusion [>8000 - >9000[
       ci   r0,>b000
       jl   quest4                             ; Restore energy [>9000 - >B000[
       ci   r0,>c000
       jl   quest5                             ; Extra life [>B000 - >C000[
* Bonus points
       li   r0,1000
       bl   @addsco                            ; Add score [>C000 - >FFFF]
       mov  @pgift,r0
       jne  quest9
       li   r0,pbonus*256+6
       mov  r0,@pgift
       li   r0,point
       bl   @speak                             ; Say something
       jmp  quest9
* Double jump
quest1:
       li   r1,512
       mov  r1,@cndcnt
       li   r1,cn_djmp
       mov  r1,@cond
       bl   @setclr
       li   r0,long
       bl   @speak                             ; Say something
       jmp  quest9
* Immunity
quest2:
       li   r1,512
       mov  r1,@cndcnt
       li   r1,cn_immu
       mov  r1,@cond
       bl   @setclr
       li   r0,fine
       bl   @speak                             ; Say something
       jmp  quest9
* Confusion
quest3:
       li   r1,512
       mov  r1,@cndcnt
       li   r1,cn_conf
       mov  r1,@cond
       bl   @setclr
       li   r0,uhoh
       bl   @speak                             ; Say something
       jmp  quest9
* Restore energy
quest4:
       bl   @rstnrg
       mov  @pgift,r0
       jne  quest9
       li   r0,pnrg*256+12
       mov  r0,@pgift
       li   r0,top
       bl   @speak                             ; Say something
       jmp  quest9
* Extra ball
quest5:
       inc  @lives
       bl   @dsplvs
       mov  @pgift,r0
       jne  quest9
       li   r0,pxball*256+4
       mov  r0,@pgift
       li   r0,more
       bl   @speak                             ; Say something
       jmp  quest9
* Speed
quest6:
       li   r1,512
       mov  r1,@cndcnt
       li   r1,cn_sped
       mov  r1,@cond
       bl   @setclr
       li   r0,double
       bl   @speak                             ; Say something
       jmp  quest9
* Return
quest9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
qstmpa:
       data >0000
* // QUESTM

***************************************************************************
* 
* Set ball color
* 
* r1: Contains color to set
* 
* 0 = White
* 1 = Green
* 2 = Blue
* 3 = Red
* 4 = Yellow
* 
setclr:
       sla  r1,1
       movb @bclrs(r1),@spratt+3
       movb @bclrs+1(r1),@spratt+7
       b    *r11
bclrs:
       data >0f0e,>030c,>0504,>0906,>0f0a
* // SETCLR

*********************************************************************
* 
* Decrement energy
* 
* r1 contains the number of units to subtract
* 
decnrg:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @energy,r2
       jeq  decnr2
       li   r0,chnrg*8+ptrnt1+32
       s    r2,r0
       bl   @vwad                              ; Set pattern VDP write address
       s    r1,r2
       mov  r2,@energy
       jgt  decnr0
       mov  @died,r0                           ; Check if already died
       jne  decnr0
       inc  @died                              ; Set as died
       clr  @jmpfrm                            ; Clear counter
* Update patterns
decnr0:
       mov  r1,r2
decnr1:
       clr  @vdpwd
       dec  r2
       jne  decnr1
* Return
decnr2:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DECNRG

*********************************************************************
* 
* Restore energy
* 
rstnrg:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r0,32
       mov  r0,@energy
* Restore patterns
       li   r0,chnrg*8+ptrnt1
       bl   @vwad
       li   r0,vdpwd
       li   r1,>007f                           ; Energy pattern
       li   r2,32
rstnr1:
       movb r1,*r0
       movb @r1lb,*r0
       dect r2
       jne  rstnr1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // RSTNRG

*********************************************************************
* 
* Display lives
* 
dsplvs:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @lives,r3
       jlt  dsplv5
       li   r0,lvsbuf
       li   r1,chball*256
       mov  r3,r2
       jeq  dsplv4
       ci   r2,6
       jle  dsplv1
       li   r2,6
dsplv1:
       movb r1,*r0+
       dec  r2
       jne  dsplv1
dsplv4:
       li   r2,6
       s    r3,r2
       jeq  dsplv3
       jlt  dsplv3
       li   r1,chspac*256
dsplv2:
       movb r1,*r0+
       dec  r2
       jne  dsplv2
* Display to VDP
dsplv3:
       li   r0,5*32+25
       li   r1,lvsbuf
       li   r2,6
       bl   @dsptxt
* Return
dsplv5:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
lvsbuf:
       byte chball,chball,chball,chball,chball,chball
* // DSPLVS

*********************************************************************
* 
* Display time
* 
dsptme:
       mov  r11,*r10+                          ; Push return address onto the stack
       clr  r3
       li   r4,maxfrm                          ; Max frames to complete level
       s    @frame,r4
       jlt  dsptm2
       li   r1,maxfrm/48+1                     ; divisor - max time / length of time scale (6*8)
       div  r1,r3                              ; Number of time scale units in R3
       mov  r3,r1                              ; Get time scale units
       andi r1,7                               ; Mod 8
       li   r0,8
       s    r1,r0                              ; Shift = 8 - (time scale units Mod 8) [1-8]
       li   r1,>ff00                           ; Pattern byte
       sla  r1,0                               ; Shift pattern byte
dsptm1:
       srl  r3,3                               ; Number of full characters
       ai   r3,tmechr                          ; Add list base address
       clr  r0
       movb *r3,@r0lb                          ; Get character pattern number to update
       sla  r0,3                               ; Multiple by 8
       ai   r0,ptrntb+7                        ; Add base address + 7 rows
       bl   @vsbw
* Return
dsptm2:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
tmechr:
       byte >fd,>fc,>fb,>fa,>fe,>77
* // DSPTME

*********************************************************************
* 
* Restore time
* 
rsttme:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r1,>ff00                           ; Pattern row
       li   r2,6
       li   r3,tmechr
rsttm1:
       clr  r0
       movb *r3+,@r0lb                         ; Get character pattern number to restore
       sla  r0,3                               ; Multiple by 8
       ai   r0,ptrntb+7                        ; Add base address + 7 rows
       bl   @vsbw                              ; Set byte
       dec  r2
       jne  rsttm1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // RSTTME

*********************************************************************
* 
* Add score
* 
* r0 contains the score to add
* 
addsco:
       mov  r11,*r10+                          ; Push return address onto the stack
       a    r0,@scorel
       jnc  addsc1
       inc  @scoreh
addsc1:
       bl   @dspsco
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // ADDSCO

*********************************************************************
* 
* Display score
* 
dspsco:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  @scoreh,r0
       mov  @scorel,r1
       li   r2,6                               ; Counter
       li   r3,10                              ; Divisor
       li   r4,numbuf+5                        ; Start backwards
* Digit loop
dspnu1:
       div  r3,r0                              ; Divide to get digit as remainder in R1
       ai   r1,chzero                          ; Add ASCII code for zero
       swpb r1                                 ; Swap to high byte
       movb r1,*r4                             ; Store digit in buffer
       dec  r4                                 ; Next digit in buffer (working backwards)
       mov  r0,r1
       clr  r0
       dec  r2                                 ; Count down
       jne  dspnu1                             ; Digit loop
* Display to VDP
       li   r0,18*32+25
       li   r1,numbuf
       li   r2,6
       bl   @dsptxt
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
numbuf:
       byte chzero,chzero,chzero,chzero,chzero,chzero
* // DSPSCO

***************************************************************************
* 
* Display level
* 
dsplvl:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r4,numbuf+4
       li   r1,chzero*256+chzero
       mov  r1,*r4
       clr  r0
       mov  @level,r1
       li   r3,10
       div  r3,r0
       ab   @r0lb,*r4+                         ; Display first digit
       ab   @r1lb,*r4+                         ; Display last digit
* Display to VDP
       li   r0,22*32+27
       li   r1,numbuf+4
       li   r2,2
       bl   @dsptxt
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DSPLVL

*********************************************************************
* 
* Display text to all name table buffers
* 
* r0: Screen offset (characters) of upper left corner
* r1: Source address
* r2: Length
* 
* Modifies r0-r5
* 
dsptxt:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r0,r3
       mov  r1,r4
       mov  r2,r5
       ai   r0,namet0
       bl   @vmbw
       mov  r3,r0
       mov  r4,r1
       mov  r5,r2
       ai   r0,namet1
       bl   @vmbw
       mov  r3,r0
       mov  r4,r1
       mov  r5,r2
       ai   r0,namet2
       bl   @vmbw
       mov  r3,r0
       mov  r4,r1
       mov  r5,r2
       ai   r0,namet3
       bl   @vmbw
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DSPTXT

***************************************************************************
* 
* Display right side panel
* 
dsppnl:
       mov  r11,*r10+                          ; Push return address onto the stack
* Copy some characters back that has been overwritten by the logo
       li   r0,112*8+ptrnt1
       li   r1,fixpat
       li   r2,16*8
       bl   @vcopy
       li   r0,112*8+colrtb
       li   r1,fixcol
       li   r2,16*8
       bl   @vcopy
* Display to all four buffers
       li   r0,namet0+vieww
       bl   @dsppn0
       li   r0,namet1+vieww
       bl   @dsppn0
       li   r0,namet2+vieww
       bl   @dsppn0
       li   r0,namet3+vieww
       bl   @dsppn0
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* Display to one name table
dsppn0:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r0,r7
       li   r8,fixmap
       li   r9,panelh                          ; Rows
dsppn1:
       mov  r7,r0
       mov  r8,r1
       li   r2,panelw                          ; Columns
       bl   @vcopy
       ai   r7,scrnw                           ; Next screen row
       ai   r8,panelw                          ; Next map row
       dec  r9
       jne  dsppn1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DSPPNL

***************************************************************************
* 
* Display logo
* 
dsplgo:
       mov  r11,*r10+                          ; Push return address onto the stack
* Screen off
       li   r0,>01a2
       bl   @vwtr
* Disable sprites
       li   r0,spratb
       li   r1,>d000
       bl   @vsbw
* Clear name table
       li   r0,namet0
       li   r1,chspac*256
       li   r2,768
       bl   @vsmw
** Patterns
       li   r0,ptrnt1
       li   r1,lgpat
       li   r2,nlogop*8
       bl   @vcopy
** Colors
       li   r0,colrtb
       li   r1,lgcol
       li   r2,nlogop*8
       bl   @vcopy
** Map
       li   r0,namet0+256
       li   r1,lgmap
       li   r2,256
       bl   @vcopy
* Set name table
       li   r0,>020a
       bl   @vwtr
* Screen on
       li   r0,>01e2
       bl   @vwtr
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // DSPLGO

***************************************************************************
* 
* VDP Multiple 8 Byte Write
* 
* The inner loop has been moved into scratch pad
* memory for a performance boost of about 10%.
* 
* r0: Starting write address in VDP RAM
* r1: Starting read address in CPU RAM
* r2: Number of groups of 8 bytes to send to the VDP RAM
* 
* r0 is modified, r1 is next read address, r2 is zero
* 
vm8bw:
       mov  r11,*r10+                          ; Push return address onto the stack
       bl   @vwad                              ; Setup write address
       li   r0,vdpwd                           ; Load VDP write data address into register
       bl   @vcpy
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // VM8BW

***************************************************************************
* 
* VDP Multiple 8 Byte High Write
* 
* Like VM8BW but sets the most significant bit of each byte written.
* Note: only works correctly for even read addresses.
* 
* r0: Starting write address in VDP RAM
* r1: Starting read address in CPU RAM (must be even)
* r2: Number of groups of 8 bytes to send to the VDP RAM
* 
* r0 is modified, r1 is next read address, r2 is zero, r3 is modified
* 
vm8bhw:
       mov  r11,*r10+                          ; Push return address onto the stack
       bl   @vwad                              ; Setup write address
       li   r3,vdpwd                           ; Load VDP write data address into register
       li   r15,>8000
vm8bh1:
       .ifne anympw
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       movb *r1+,r0
       soc  r15,r0
       movb r0,*r3
       .else 
       mov  *r1+,r0                            ; Read word from CPU RAM
       ori  r0,>8080                           ; Set most significant bits
       movb r0,*r3                             ; Send MSB to VDP
       movb @r0lb,*r3                          ; Send LSB to VDP
       mov  *r1+,r0                            ; Repeat 2
       ori  r0,>8080                           ;
       movb r0,*r3                             ;
       movb @r0lb,*r3                          ;
       mov  *r1+,r0                            ; Repeat 3
       ori  r0,>8080                           ;
       movb r0,*r3                             ;
       movb @r0lb,*r3                          ;
       mov  *r1+,r0                            ; Repeat 4 times
       ori  r0,>8080                           ;
       movb r0,*r3                             ;
       movb @r0lb,*r3                          ;
       .endif 
       dec  r2                                 ; Group counter
       jne  vm8bh1                             ; Loop if not done
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // VM8BHW

***************************************************************************
* 
* Fast CPU to VDP copy, replaces VMBW
* 
* r0: Destination address
* r1: Source address
* r2: Number of bytes to copy
* 
* r0-r3 are modified
* 
vdpcp0:
       mov  r11,*r10+                          ; Push return address onto the stack
       jmp  vdpcp1
vdpcp:
       mov  r11,*r10+                          ; Push return address onto the stack
       swpb r0
       movb r0,@vdpwa                          ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                           ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
vdpcp1:
       li   r0,vdpwd
       mov  r2,r3
       srl  r2,3                               ; Number of groups of 8
       jeq  vdpcp2
       bl   @vcpy
       andi r3,>0007                           ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r3
       jne  vdpcp2
* Return
vdpcp3:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // VDPCP

***************************************************************************
* 
* VDP copy unrolled loop
* 
vcpy8:
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       dec  r2
       jne  vcpy8
       b    *r11
vcpy8e:
       equ   $
* // VCPY8

***************************************************************************
* 
* VDP Set Read Address
* 
* r0   Address to set VDP address counter to
* 
vrad:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       andi r0,>3fff                           ; Make sure the two MSbits are 00 for read
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
       b    *r11
* // VRAD

***************************************************************************
* 
* VDP Set Write Address
* 
* r0   Address to set VDP address counter to
* 
vwad:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       ori  r0,>4000                           ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
       andi r0,>3fff                           ; Restore R0 top two MSbits
       b    *r11
* // VWAD / VRAD

***************************************************************************
* 
* VDP Single Byte Write
* 
* r0   Write address in VDP RAM
* r1   MSB of r1 sent to VDP RAM
* 
* r0 is modified, but can be restored with: ANDI r0,>3FFF
* 
vsbw:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       ori  r0,>4000                           ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                          ; Write byte to VDP RAM
       b    *r11
* // VSBW

***************************************************************************
* 
* VDP Single Byte Multiple Write
* 
* r0   Starting write address in VDP RAM
* r1   MSB of r1 sent to VDP RAM
* r2   Number of times to write the MSB byte of r1 to VDP RAM
* 
* r0 is modified, but can be restored with: ANDI r0,>3FFF
* 
vsmw:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       ori  r0,>4000                           ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
vsmwlp:
       movb r1,@vdpwd                          ; Write byte to VDP RAM
       dec  r2                                 ; Byte counter
       jne  vsmwlp                             ; Check if done
       b    *r11
* // VSMW

***************************************************************************
* 
* VDP Multiple Byte Write
* 
* r0   Starting write address in VDP RAM
* r1   Starting read address in CPU RAM
* r2   Number of bytes to send to the VDP RAM
* 
* r0 is modified, but can be restored with: ANDI r0,>3FFF
* 
vmbw:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       ori  r0,>4000                           ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
vmbwlp:
       movb *r1+,@vdpwd                        ; Write byte to VDP RAM
       dec  r2                                 ; Byte counter
       jne  vmbwlp                             ; Check if done
       b    *r11
* // VMBW

***************************************************************************
* 
* VDP Single Byte Read
* 
* r0   Read address in VDP RAM
* r1   MSB of r1 set to byte from VDP RAM
* 
vsbr:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
       movb @vdprd,r1                          ; Read byte from VDP RAM
       b    *r11
* // VSBR

***************************************************************************
* 
* VDP Multiple Byte Read
* 
* r0   Starting read address in VDP RAM
* r1   Starting write address in CPU RAM
* r2   Number of bytes to read from VDP RAM
* 
vmbr:
       movb @r0lb,@vdpwa                       ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                          ; Send high byte of VDP RAM write address
vmbrlp:
       movb @vdprd,*r1+                        ; Read byte from VDP RAM
       dec  r2                                 ; Byte counter
       jne  vmbrlp                             ; Check if finished
       b    *r11
* // VMBR

***************************************************************************
* 
* VDP Write To Register
* 
* r0 MSB    VDP register to write to
* r0 LSB    Value to write
* 
vwtr:
       movb @r0lb,@vdpwa                       ; Send low byte (value) to write to VDP register
       ori  r0,>8000                           ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                          ; Send high byte (address) of VDP register
       b    *r11
* // VWTR

***************************************************************************
* 
* VDP RAM copy
* 
* r0: Destination address (word aligned)
* r1: Source address (word aligned)
* r2: Number of bytes to copy
* 
vcpsze:
       equ  8                                  ; Buffer size
* 
vcopy:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r0,r3                              ; Destionation
       mov  r1,r4                              ; Source
       mov  r2,r5                              ; Count
       li   r6,vcpsze
vcopy1:
       mov  r4,r0
       li   r1,vcpbuf
       mov  r6,r2
       bl   @vmbr
       mov  r3,r0
       li   r1,vcpbuf
       mov  r6,r2
       bl   @vmbw
       a    r6,r3
       a    r6,r4
       s    r6,r5
       jgt  vcopy1
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
vcpbuf:
       bss  vcpsze
* // COPY

***************************************************************************
* 
* CPU RAM copy
* 
* r0: Destination address (word aligned)
* r1: Source address (word aligned)
* r2: Number of bytes to copy (multiple of 2)

copy:
       mov  *r1+,*r0+
       dect r2
       jne  copy
* Return
       b    *r11
* // COPY

***************************************************************************
* 
* Wait for fire button
* 
* r2: Number of frames to wait before returning, or 0 for never
* 
wtfire:
       mov  r11,*r10+                          ; Push return address onto the stack
wtfir1:
       li   r0,>0606                           ; Fire button
       bl   @chkkey
       jne  wtfir2
       bl   @ckquit                            ; Check quit
       bl   @rand                              ; Randomize
       inc  @frame
       bl   @vsync
       mov  r2,r2
       jeq  wtfir1
       dec  r2
       jne  wtfir1
* Return
wtfir2:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // WTFIRE

***************************************************************************
* 
* Check key
* 
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
* 
* Column   0      1    2    3    4    5     6       7
* Row
* >0006      =      .    ,    M    N    /    Fire    Fire
* >0008    Space    L    K    J    H    ;    Left    Left
* >000A    Enter    O    I    U    Y    P    Right   Right
* >000C             9    8    7    6    0    Down    Down
* >000E    Fctn     2    3    4    5    1    Up      Up
* >0010    Shift    S    D    F    G    A
* >0012    Ctrl     W    E    R    T    Q
* >0014             X    C    V    B    Z
* 
* On return NEQ means that the key is pressed
* 
chkkey:
       li   r12,>0024                          ; CRU address of the column decoder
       ldcr r0,3                               ; Select column
       andi r0,>00ff
       mov  r0,r12                             ; Select row
       tb   0                                  ; Test key, EQ if not pressed
       b    *r11
* // CHKKEY

*********************************************************************
* 
* Generate a pseudo random number
* 
* On return r0 contains the number, which is also stored at @RANDNO
* 
* r14 and r15 are modified
* 
rand:
       li   r14,28643                          ; A prime number to multiply by
       mpy  @randno,r14                        ; Multiply by last random number
       ai   r15,31873                          ; Add a prime number
       mov  @frame,r0                          ; Use the VSYNC tick to mix it up a little
       src  r15,0                              ; Mix up the number to break odd/even pattern
rand1:
       mov  r15,@randno                        ; Save this number for next time
       mov  r15,r0                             ; Copy as return value
       b    *r11
* // RAND

*********************************************************************************
* 
* Play music
* 
playmu:
       mov  r11,*r10+                          ; Push return address onto the stack
       .ifne bgtime
       li   r0,>0701
       bl   @vwtr
       .endif 
       bl   @stplay
       lwpi wrksp
       mov  @plyrws+14,r0                      ; Check if music is done
       jne  playm1
* Restart music
       bl   @initmu
* Return
playm1:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // PLAYMU

*********************************************************************************
* 
* Initialize music
* 
initmu:
       mov  r11,*r10+                          ; Push return address onto the stack
       li   r1,music
       li   r2,0
       bl   @stinit
* Return
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // INITMU

*********************************************************************
* 
* Mute sound
* 
mtesnd:
       li   r0,mutetb                          ; Mute all
       li   r2,4
mtesn1:
       movb *r0+,@sound
       dec  r2
       jne  mtesn1
       b    *r11
mutetb:
       byte >9f,>bf,>df,>ff
* // MTESND

*********************************************************************
* 
* Play sound
* 
* r0: pointer to sound list row
* 
plysnd:
       clr  r2
       movb *r0+,@r2lb
plysn1:
       movb *r0+,@sound
       dec  r2
       jne  plysn1
       b    *r11
* // PLYSND

*********************************************************************
* 
* Speak a word from the resident vocabulary
* 
* r0 points to the word to say.
* 
long:
       equ  >40d3                              ; Long jump
point:
       equ  >50ec                              ; Bonus points
uhoh:
       equ  >71f4                              ; Confusion
good:
       equ  >30d6                              ;
finish:
       equ  >2b94                              ; Level completed
more:
       equ  >4642                              ; Extra life
top:
       equ  >6f8d                              ; Energy
yes:
       equ  >7d58                              ;
no:
       equ  >3c4f                              ; Space
connec:
       equ  >208b                              ; Switch
fine:
       equ  >2b1e                              ; Immunity
double:
       equ  >2599                              ; Speed
ready:
       equ  >56b3
a1:
       equ  >1700
oh:
       equ  >4b7d
* 
speak:
       li   r2,4
speak1:
       src  r0,4
       mov  r0,r1
       src  r1,4
       andi r1,>0f00
       ori  r1,>4000
       movb r1,@spchwt
       dec  r2
       jne  speak1
       li   r0,>4000
       movb r0,@spchwt
       li   r0,>5000
       movb r0,@spchwt
       b    *r11
* // SPEAK

*********************************************************************************
* 
* Change scroll tile colors
* 
* r0 contains a pointer to the zero terminated list of from/to color bytes
* 
chgclr:
       mov  r11,*r10+                          ; Push return address onto the stack
       mov  r0,r0
       jeq  chgcl9
chgcl1:
       mov  *r0,r1                             ; Get from/to color bytes
       movb @r1lb,r4
       jeq  chgcl9                             ; Zero terminated
       mov  @stlnum,r2                         ; Number of scroll tiles
       sla  r2,6                               ; number of bytes to update (8 frames * 8 bytes/tile)
       li   r3,clfrm0                          ; Pointer to color bytes
chgcl2:
       cb   r1,*r3+
       jne  chgcl3
       dec  r3
       movb r4,*r3+
chgcl3:
       dec  r2
       jne  chgcl2
       inct r0
       jmp  chgcl1
* Return
chgcl9:
       dect r10                                ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
* // CHGCLR

***************************************************************************
* 
* Data
* 
levels:
       data mtmap1,edlst1,swlst1,0
       data mtmap2,edlst2,swlst2,0
       data mtmap3,edlst3,swlst3,clrch1
       data mtmap4,edlst4,swlst4,clrch1
       data mtmap5,edlst5,swlst5,0
       data mtmap6,edlst6,swlst6,0
       data mtmap7,edlst7,swlst7,clrch1
       data mtmap8,edlst8,swlst8,0
       data 0

clrch1:
       byte >54,>df,>96,>3c,>00,>00            ; ,>F1,>F6,>E1,>E6

jmppat:
       byte pball2,pball2,pball1,pball1,pball1,pball1,pball0,pball0
       byte pball0,pball0,pball1,pball1,pball1,pball1,pball2,pball2
jmphgt:
       byte 1,1,1,0,1,0,1,0,0,-1,0,-1,0,-1,-1,-1

diepat:
       byte pball2,pball2+4,pball3,pball3+4,pball4,pball4+4,pball5,pball5+4
       byte pspark+12,pspark+12,pspark+8,pspark+8,pspark+4,pspark+4,pspark,pspark
       byte pspark+4,pspark+4,pspark+8,pspark+8,pspark+12,pspark+12,pempty,pempty

* Sprite attributes
spratt:
       byte >80,>60,pball2,>0f                 ; Ball top layer
       byte >80,>60,pball2+4,>0e               ; Ball bottom layer
       byte >c0,>00,penemy,>0f                 ; Enemy 1 plane 1
       byte >c0,>00,penemy+4,>01               ; Enemy 1 plane 2
       byte >c0,>00,penemy,>0f                 ; Enemy 2 plane 1
       byte >c0,>00,penemy+4,>01               ; Enemy 2 plane 2
       byte >c0,>00,penemy,>0f                 ; Enemy 3 plane 1
       byte >c0,>00,penemy+4,>01               ; Enemy 3 plane 2
       byte >c0,>00,penemy,>0f                 ; Enemy 4 plane 1
       byte >c0,>00,penemy+4,>01               ; Enemy 4 plane 2
       byte >c0,>00,pspark,>0a                 ; Sparkle 1
       byte >c0,>00,pspark,>0a                 ; Sparkle 2
       byte >c0,>00,pspark,>0a                 ; Sparkle 3
       byte >80,>60,pball2+4,>01               ; Ball shadow

* Press fire sprite attributes
prfatt:
       byte >80,>c0,pprf,>0f
       byte >80,>d0,pprf+4,>0f
       byte >80,>e0,pprf+8,>0f
       byte >d0,>00

* Game over sprite attributes
gmoatt:
       byte >58,>50,pgmo,>0f
       byte >58,>60,pgmo+4,>0f
       byte >59,>51,pgmo,>01
       byte >59,>61,pgmo+4,>01
       byte >d0,>00

* Scroll tile counts
stlnum:
       data >0000                              ; Actual number of scroll tiles
stlnu1:
       equ  76                                 ; Max number of scroll tiles - determines allocated buffer sizes
stlnu2:
       data >0000                              ; 2/3 of STLNUM
stlnu3:
       data >0000                              ; 1/3 of STLNUM


****************************************
* Meta Tile definitions (NW, NE, SW, SE)
****************************************
mtiles:
       equ  $
mtile0:
       byte >00,>01,>08,>09
mtile1:
       byte >02,>03,>0a,>0b
mtile2:
       byte >04,>05,>0c,>0d
mtile3:
       byte >06,>07,>0e,>0f
mtile4:
       byte >10,>11,>18,>19
mtile5:
       byte >12,>13,>1a,>1b
mtile6:
       byte >14,>15,>1c,>1d
mtile7:
       byte >16,>17,>1e,>1f

***************************************************************************
* 
* Include data files
* 
       copy "tiplayer.a99"
* COPY "tiplayersfx.a99"
       copy "level1.a99"
       copy "level2.a99"
       copy "level3.a99"
       copy "level4.a99"
       copy "level5.a99"
       copy "level6.a99"
       copy "level7.a99"
       copy "level8.a99"
music:
       bcopy "monty-short.vgm.spf"
* FXCOIN BCOPY "coin.vgm.spf"
* FXJUMP BCOPY "longjump.vgm.spf"
buffs:
* Will be overwritten by buffers after uploading to VDP
       copy "fixed.a99"
       copy "sprites.a99"
       copy "logo.a99"

***************************************************************************
* 
* Buffers
* 
frmsiz:
       equ  stlnu1*8

stiles:
       equ  buffs                              ; Scroll tile lookup table
rowbuf:
       equ  stiles+224                         ; Buffer for storing one map row
enmlst:
       equ  rowbuf+mapw                        ; Enemy list
swlist:
       equ  enm_sz*8+2+enmlst                  ; Switch list
ptfrm0:
       equ  sw_sz*4+2+swlist                   ; Pattern frame 0
ptfrm7:
       equ  7*frmsiz+ptfrm0                    ; Pattern frame 7
clfrm0:
       equ  frmsiz+ptfrm7                      ; Color frame 0
clfrm7:
       equ  7*frmsiz+clfrm0                    ; Color frame 7
rammax:
       equ  frmsiz+clfrm7                      ; Max used RAM address

***************************************************************************
* 
* Lower memory
* 
mtmap:
       equ  >2000                              ; Meta tile map (unpacked)
map:
       equ  mapw*maph/4+mtmap                  ; Expanded map
mape:
       equ  mapw*maph+map                      ; End of map

       aorg >2ffc
       b    @start

       aorg >3000
       copy "patterns.a99"

       end  start

* The End
